{"meta":{"title":"Martin's Blog","subtitle":"Martin's Blog","description":"记录编程的点滴","author":"Martin","url":"https://martinbzdqsm.github.io"},"pages":[{"title":"about","date":"2017-01-16T06:01:31.000Z","updated":"2017-01-16T06:01:31.885Z","comments":true,"path":"about/index.html","permalink":"https://martinbzdqsm.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-01-16T06:00:27.000Z","updated":"2017-01-16T06:02:22.638Z","comments":false,"path":"categories/index.html","permalink":"https://martinbzdqsm.github.io/categories/index.html","excerpt":"","text":""},{"title":"gallery","date":"2017-01-16T10:41:03.000Z","updated":"2017-01-16T10:41:03.210Z","comments":true,"path":"gallery/index.html","permalink":"https://martinbzdqsm.github.io/gallery/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-01-16T04:57:20.000Z","updated":"2017-01-16T06:13:12.457Z","comments":true,"path":"tags/index.html","permalink":"https://martinbzdqsm.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Kotlin学习笔记(二)","slug":"Kotlin学习笔记(二)","date":"2017-02-06T05:41:32.000Z","updated":"2017-02-06T08:44:51.743Z","comments":true,"path":"2017/02/06/Kotlin学习笔记(二)/","link":"","permalink":"https://martinbzdqsm.github.io/2017/02/06/Kotlin学习笔记(二)/","excerpt":"本文只是作者学习笔记，如果想学习kotlin的朋友建议去看Kotlin for android developers,这里大部分都是摘抄自这本书。 数据类基本写法它可以让你避免创建Java中的用于保存状态但又操作非常简单的POJO的模版代码。它们通常只提供了用于访问它们属性的简单的getter和setter。代码如下：1data class Human(val name: String, val sex: Int, val country: String) 数据类操作 equals(): 它可以比较两个对象的属性来确保他们是相同的。 hashCode(): 我们可以得到一个hash值，也是从属性中计算出来的。 copy(): 你可以拷贝一个对象，可以根据你的需要去修改里面的属性。我们会在稍后的例子中看到。 一系列可以映射对象到变量中的函数。 例如：简单的复制一个类并修改:12val human= Human(\"Marin\",1,\"china\")val human2=human.copy(name =\"Martin2\") 映射对象到变量中1val (name, sex, country) = human 相当于：123val name = human.component1()val sex = human.component2()val country = human.component3() 而这些变量系统会自动生成,这个特性背后的逻辑是非常强大的，它可以在很多情况下帮助我们简化代码。例如：123for ((key, value) in map) &#123; Log.d(\"map\", \"key:$key, value:$value\")&#125; 操作符 Kotin有一些固定数量象征性的操作符，我们可以在任何类中很容易地使用它们。方法是创建一个方法，方法名为保留的操作符关键字，这样就可以让这个操作符的行为映射到这个方法。重载这些操作符可以增加代码可读性和简洁性。 操作符表这里你可以看见一系列包括操作符和对应方法的表。对应方法必须在指定的类中通过各种可能性被实现。 一元操作符 操作符 函数 +a a.unaryPlus() -a a.unaryMinus() !a a.not() a++ a.inc() a– a.dec() 二元操作符 操作符 函数 a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.mod(b) a..b a.rangeTo(b) a in b a.contains(b) a !in b !a.contains(b) a += b a.plusAssign(b) a -= b a.minusAssign(b) a *= b a.timesAssign(b) a /= b a.divAssign(b) a %= b a.modAssign(b) 数组操作符 操作符 函数 a[i] a.get(i) a[i, j] a.get(i, j) a[i_1, …, i_n] a.get(i_1, …, i_n) a[i] = b a.set(i, b) a[i, j] = b a.set(i, j, b) a[i_1, …, i_n] = b a.set(i_1, …, i_n, b) 等于操作符 操作符 函数 a == b a?.equals(b) ?: b === null a != b !(a?.equals(b) ?: b === null) 相等操作符有一点不同，为了达到正确合适的相等检查做了更复杂的转换，因为要得到一个确切的函数结构比较，不仅仅是指定的名称。方法必须要如下准确地被实现： 1operator fun equals(other: Any?): Boolean 操作符===和!==用来做身份检查（它们分别是Java中的==和!=），并且它们不能被重载。 函数调用 方法 调用 a(i) a.invoke(i) a(i, j) a.invoke(i, j) a(i_1, …, i_n) a.invoke(i_1, …, i_n)","text":"本文只是作者学习笔记，如果想学习kotlin的朋友建议去看Kotlin for android developers,这里大部分都是摘抄自这本书。 数据类基本写法它可以让你避免创建Java中的用于保存状态但又操作非常简单的POJO的模版代码。它们通常只提供了用于访问它们属性的简单的getter和setter。代码如下：1data class Human(val name: String, val sex: Int, val country: String) 数据类操作 equals(): 它可以比较两个对象的属性来确保他们是相同的。 hashCode(): 我们可以得到一个hash值，也是从属性中计算出来的。 copy(): 你可以拷贝一个对象，可以根据你的需要去修改里面的属性。我们会在稍后的例子中看到。 一系列可以映射对象到变量中的函数。 例如：简单的复制一个类并修改:12val human= Human(\"Marin\",1,\"china\")val human2=human.copy(name =\"Martin2\") 映射对象到变量中1val (name, sex, country) = human 相当于：123val name = human.component1()val sex = human.component2()val country = human.component3() 而这些变量系统会自动生成,这个特性背后的逻辑是非常强大的，它可以在很多情况下帮助我们简化代码。例如：123for ((key, value) in map) &#123; Log.d(\"map\", \"key:$key, value:$value\")&#125; 操作符 Kotin有一些固定数量象征性的操作符，我们可以在任何类中很容易地使用它们。方法是创建一个方法，方法名为保留的操作符关键字，这样就可以让这个操作符的行为映射到这个方法。重载这些操作符可以增加代码可读性和简洁性。 操作符表这里你可以看见一系列包括操作符和对应方法的表。对应方法必须在指定的类中通过各种可能性被实现。 一元操作符 操作符 函数 +a a.unaryPlus() -a a.unaryMinus() !a a.not() a++ a.inc() a– a.dec() 二元操作符 操作符 函数 a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.mod(b) a..b a.rangeTo(b) a in b a.contains(b) a !in b !a.contains(b) a += b a.plusAssign(b) a -= b a.minusAssign(b) a *= b a.timesAssign(b) a /= b a.divAssign(b) a %= b a.modAssign(b) 数组操作符 操作符 函数 a[i] a.get(i) a[i, j] a.get(i, j) a[i_1, …, i_n] a.get(i_1, …, i_n) a[i] = b a.set(i, b) a[i, j] = b a.set(i, j, b) a[i_1, …, i_n] = b a.set(i_1, …, i_n, b) 等于操作符 操作符 函数 a == b a?.equals(b) ?: b === null a != b !(a?.equals(b) ?: b === null) 相等操作符有一点不同，为了达到正确合适的相等检查做了更复杂的转换，因为要得到一个确切的函数结构比较，不仅仅是指定的名称。方法必须要如下准确地被实现： 1operator fun equals(other: Any?): Boolean 操作符===和!==用来做身份检查（它们分别是Java中的==和!=），并且它们不能被重载。 函数调用 方法 调用 a(i) a.invoke(i) a(i, j) a.invoke(i, j) a(i_1, …, i_n) a.invoke(i_1, …, i_n)","categories":[{"name":"Android","slug":"Android","permalink":"https://martinbzdqsm.github.io/categories/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://martinbzdqsm.github.io/tags/kotlin/"},{"name":"android","slug":"android","permalink":"https://martinbzdqsm.github.io/tags/android/"}]},{"title":"Kotlin学习笔记(一)","slug":"Kotlin学习笔记(一)","date":"2017-02-04T10:34:13.000Z","updated":"2017-02-06T06:04:24.181Z","comments":true,"path":"2017/02/04/Kotlin学习笔记(一)/","link":"","permalink":"https://martinbzdqsm.github.io/2017/02/04/Kotlin学习笔记(一)/","excerpt":"本文只是作者学习笔记，如果想学习kotlin的朋友建议去看Kotlin for android developers,这里大部分都是摘抄自这本书。 环境配置：插件安装打开studio插件界面，查找kotliin并安装下图中的两个插件。其中Kotlin Android Extensions的作用相当于Butterknife。 Gradle配置修改父build.gradle： 其中kotlin版本号根据这个kotlin地址进行修改 anko的版本则看anko 1234567891011121314151617buildscript &#123; ext.support_version = '*.*.*' ext.kotlin_version = '*.*.*' ext.anko_version = '*.*.*' repositories &#123; jcenter() dependencies &#123; classpath 'com.android.tools.build:gradle:1.5.0' classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" &#125; &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 子Gradle配置：1234567891011121314151617181920apply plugin: 'com.android.application'apply plugin: 'kotlin-android'apply plugin: 'kotlin-android-extensions'android &#123; ...&#125;dependencies &#123; compile \"com.android.support:appcompat-v7:$support_version\" compile \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\" compile \"org.jetbrains.anko:anko-common:$anko_version\"&#125;buildscript &#123; repositories &#123;jcenter() &#125; dependencies &#123; classpath \"org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version\" &#125; &#125; 基本类型 在kotlin中没有java中的原始基本类型，一切都是对象。 基本类型例如：int ，float ，double依然存在但是都是作为对象。 数字类型不会自动转型，需要明确的类型转换： 12345var i:Int=7var d:Double=i.toDouble()var c:Char='c'var i:Int=c.toInt() 位运算使用and和or来代替 | 和 &amp; String类型可以像数组一样访问：12val s = \"Martin\"val c = s[2] //则c为\"a\" 变量 可变变量 var 不可变变量 val（和final一致） 类与函数：类继承和构造方法:默认任何类都是基础继承自Any（类似object），所有类默认都是不可继承的即final，只能继承open或者abstract的类。 类有一个默认唯一的的构造器 init，其参数在类名后面添加即可：1234567891011open class Father(name: String, surname: String) &#123; init &#123; &#125;&#125;class Child(name: String, surname: String) : Father(name, surname) &#123; init &#123; name?.toString() //这里拿得到构造参数 &#125;&#125; 类的属性自定类会默认使用getter和setter，你也可以使用field这个预留字段来进行访问：1234567891011121314class Person &#123; var name: String = \"\" get() = field.toUpperCase()//toUpperCase使字符全部大写 set(value) &#123; field = \"Name: $value\" &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var customer: Person = Person() println(customer.name) // ABC customer.name = \"aaa\" println(customer.name) //NAME: AAA&#125; 点击查看field的属性时会发现显示如下图： 咦！！既然是final var name！！final var那不等同于val？还能这样赋值！那不等同于下面这段代码么？1234 int b = 9; final int a = b; b = 10;` 于是我仔细看了Kotlin for android developers的解释之后大概明白了，field只会使用该属性的getter与setter，而不是直接操作该属性且仅有属性访问器内部才有能力进行修改 ，这样就讲得过去了，，那么实际java代码应该是这样子的：1234567891011String name = \"Martin\";public final String getName() &#123; final String field = name; return field.toUpperCase();&#125;public final void setName(String name) &#123; final String field = (\"Name:\" + name); this.name = field;&#125; 函数和函数参数函数注意下基本的写法就好了,普通写法：123fun add(a: Int, b: Int): Int &#123; return a + b &#125; 简约写法：1fun add(a: Int, b: Int): Int = a + b 函数参数可以指定一个默认值，这样在函数使用的时候可以不用考虑传值，这样可以避免你需要重载的函数123456fun test() &#123; Log.i(\"OverLoadTest\", add(1, 2).toString()) Log.i(\"OverLoadTest\", add(1).toString()) &#125; fun add(a: Int, b: Int = 2): Int = a + b","text":"本文只是作者学习笔记，如果想学习kotlin的朋友建议去看Kotlin for android developers,这里大部分都是摘抄自这本书。 环境配置：插件安装打开studio插件界面，查找kotliin并安装下图中的两个插件。其中Kotlin Android Extensions的作用相当于Butterknife。 Gradle配置修改父build.gradle： 其中kotlin版本号根据这个kotlin地址进行修改 anko的版本则看anko 1234567891011121314151617buildscript &#123; ext.support_version = '*.*.*' ext.kotlin_version = '*.*.*' ext.anko_version = '*.*.*' repositories &#123; jcenter() dependencies &#123; classpath 'com.android.tools.build:gradle:1.5.0' classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" &#125; &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 子Gradle配置：1234567891011121314151617181920apply plugin: 'com.android.application'apply plugin: 'kotlin-android'apply plugin: 'kotlin-android-extensions'android &#123; ...&#125;dependencies &#123; compile \"com.android.support:appcompat-v7:$support_version\" compile \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\" compile \"org.jetbrains.anko:anko-common:$anko_version\"&#125;buildscript &#123; repositories &#123;jcenter() &#125; dependencies &#123; classpath \"org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version\" &#125; &#125; 基本类型 在kotlin中没有java中的原始基本类型，一切都是对象。 基本类型例如：int ，float ，double依然存在但是都是作为对象。 数字类型不会自动转型，需要明确的类型转换： 12345var i:Int=7var d:Double=i.toDouble()var c:Char='c'var i:Int=c.toInt() 位运算使用and和or来代替 | 和 &amp; String类型可以像数组一样访问：12val s = \"Martin\"val c = s[2] //则c为\"a\" 变量 可变变量 var 不可变变量 val（和final一致） 类与函数：类继承和构造方法:默认任何类都是基础继承自Any（类似object），所有类默认都是不可继承的即final，只能继承open或者abstract的类。 类有一个默认唯一的的构造器 init，其参数在类名后面添加即可：1234567891011open class Father(name: String, surname: String) &#123; init &#123; &#125;&#125;class Child(name: String, surname: String) : Father(name, surname) &#123; init &#123; name?.toString() //这里拿得到构造参数 &#125;&#125; 类的属性自定类会默认使用getter和setter，你也可以使用field这个预留字段来进行访问：1234567891011121314class Person &#123; var name: String = \"\" get() = field.toUpperCase()//toUpperCase使字符全部大写 set(value) &#123; field = \"Name: $value\" &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var customer: Person = Person() println(customer.name) // ABC customer.name = \"aaa\" println(customer.name) //NAME: AAA&#125; 点击查看field的属性时会发现显示如下图： 咦！！既然是final var name！！final var那不等同于val？还能这样赋值！那不等同于下面这段代码么？1234 int b = 9; final int a = b; b = 10;` 于是我仔细看了Kotlin for android developers的解释之后大概明白了，field只会使用该属性的getter与setter，而不是直接操作该属性且仅有属性访问器内部才有能力进行修改 ，这样就讲得过去了，，那么实际java代码应该是这样子的：1234567891011String name = \"Martin\";public final String getName() &#123; final String field = name; return field.toUpperCase();&#125;public final void setName(String name) &#123; final String field = (\"Name:\" + name); this.name = field;&#125; 函数和函数参数函数注意下基本的写法就好了,普通写法：123fun add(a: Int, b: Int): Int &#123; return a + b &#125; 简约写法：1fun add(a: Int, b: Int): Int = a + b 函数参数可以指定一个默认值，这样在函数使用的时候可以不用考虑传值，这样可以避免你需要重载的函数123456fun test() &#123; Log.i(\"OverLoadTest\", add(1, 2).toString()) Log.i(\"OverLoadTest\", add(1).toString()) &#125; fun add(a: Int, b: Int = 2): Int = a + b","categories":[{"name":"Android","slug":"Android","permalink":"https://martinbzdqsm.github.io/categories/Android/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://martinbzdqsm.github.io/tags/kotlin/"},{"name":"android","slug":"android","permalink":"https://martinbzdqsm.github.io/tags/android/"}]},{"title":"Svg渐绘动画","slug":"Svg渐绘动画","date":"2017-01-16T07:53:59.000Z","updated":"2017-02-04T07:59:42.155Z","comments":true,"path":"2017/01/16/Svg渐绘动画/","link":"","permalink":"https://martinbzdqsm.github.io/2017/01/16/Svg渐绘动画/","excerpt":"先上图： 点子来自于一次情人节的礼物思考，想着能不能不俗套的去送花发红包之类的，再加上妹子也是做技术的，所以就想着搞了一个这个。 这个效果的原理是基于PathView的，可是PathView并不能满足我的需求，于是乎我就开始下手自己修改了。 下面我会一边分析PathView的实现过程，一边描述我是如何修改的(GIF图很多小心流量)。如果你不想看的话项目地址在这https://github.com/MartinBZDQSM/PathDraw 动画效果如果你了解PathView的动画的话，你就知道它的动画分为两种情况1.getPathAnimator 并行效果2.getSequentialPathAnimator 顺序效果如果你想知道它的实现原理建议查看PathView当中的两个静态内部类AnimatorBuilder和AnimatorSetBuilder。但是当我使用AnimatorSetBuilder 进行顺序绘制的时候我发现效果其实并不好，为什么不好哪里不好呢？看它的源码：1234567891011/** * Sets the duration of the animation. Since the AnimatorSet sets the duration for each * Animator, we have to divide it by the number of paths. * * @param duration - The duration of the animation. * @return AnimatorSetBuilder. */ public AnimatorSetBuilder duration(final int duration) &#123; this.duration = duration / paths.size(); return this; &#125; 看完以上代码你就会知道PathView的作者计算出来的动画时间是你设置的平均时间，也就是说不管我这条path的路径到底有多长，所有path的执行时间都是一样的。那我画一个点和画一条直线的时间都是一样的是不是有点扯？所以我在这里增加了平均时间的计算，根据计算path的长度在总长度中的占比，然后单个设置时间,进行顺序轮播,我也试过使用AnimatorSet单独设置Animator的时间,但是好像并没有效果,所以我用比较蠢点方法进行了实现，大致修改的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * Default constructor. * * @param pathView The view that must be animated. */public AnimatorSetBuilder(final PathDrawingView pathView) &#123; paths = pathView.mPaths; if (pathViewAnimatorListener == null) &#123; pathViewAnimatorListener = new PathViewAnimatorListener(); &#125; for (PathLayer.SvgPath path : paths) &#123; path.setAnimationStepListener(pathView); ObjectAnimator animation = ObjectAnimator.ofFloat(path, \"length\", 0.0f, path.getLength()); totalLenth = totalLenth + path.getLength(); animators.add(animation); &#125; for (int i = 0; i &lt; paths.size(); i++) &#123; long animationDuration = (long) (paths.get(i).getLength() * duration / totalLenth); Animator animator = animators.get(i); animator.setStartDelay(delay); animator.setDuration(animationDuration); animator.addListener(pathViewAnimatorListener); &#125;&#125;/** * Starts the animation. */public void start() &#123; resetAllPaths(); for (Animator animator : animators) &#123; animator.cancel(); &#125; index = 0; startAnimatorByIndex();&#125;public void startAnimatorByIndex() &#123; if (index &gt;= paths.size()) &#123; return; &#125; Animator animator = animators.get(index); animator.start();&#125;/** * Sets the length of all the paths to 0. */private void resetAllPaths() &#123; for (PathLayer.SvgPath path : paths) &#123; path.setLength(0); &#125;&#125;/** * Called when the animation start. */public interface ListenerStart &#123; /** * Called when the path animation start. */ void onAnimationStart();&#125;/** * Called when the animation end. */public interface ListenerEnd &#123; /** * Called when the path animation end. */ void onAnimationEnd();&#125;/** * Animation listener to be able to provide callbacks for the caller. */private class PathViewAnimatorListener implements Animator.AnimatorListener &#123; @Override public void onAnimationStart(Animator animation) &#123; if (index &lt; paths.size() - 1) &#123; paths.get(index).isMeasure = true; PathDrawingView.isDrawing = true; if (index == 0 &amp;&amp; listenerStart != null) listenerStart.onAnimationStart(); &#125; &#125; @Override public void onAnimationEnd(Animator animation) &#123; if (index &gt;= paths.size() - 1) &#123; PathDrawingView.isDrawing = false; if (animationEnd != null) animationEnd.onAnimationEnd(); &#125; else &#123; if (index &lt; paths.size() - 1) &#123; paths.get(index).isMeasure = false; index++; startAnimatorByIndex(); &#125; &#125; &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125;&#125; 画笔动态跟踪PathView中线条渐变是通过截取path当中的片段做成的，看码:1234567891011121314/** * Sets the length of the path. * * @param length The length to be set. */ public void setLength(float length) &#123; path.reset(); measure.getSegment(0.0f, length, path, true); path.rLineTo(0.0f, 0.0f); if (animationStepListener != null) &#123; animationStepListener.onAnimationStep(); &#125; &#125; 既然动画的原理是通过改变截取的长度做到的，那么只要能获取到截取长度最后的那个点是不是就可以充当轨迹了？所以这里只需要添加一个锚点，每当截取长度变化的时候，锚点也跟着改变,看代码：123456789public void setLength(float length) &#123; path.reset(); measure.getSegment(0.0f, length, path, true); measure.getPosTan(length, point, null);//跟踪锚点 path.rLineTo(0.0f, 0.0f); if (animationStepListener != null) &#123; animationStepListener.onAnimationStep(); &#125; &#125; 笔尖移动的原理，需要提前计算好笔尖在画笔图片中的坐标，然后对照着锚点进行移动就行了。Tips:这里我的画笔图片还没有针对画布宽高进行缩放，所以在不同分辨率的情况下画笔显示的大小可能是不一致的。 我认知的FillPathView中对于Path的Paint选的是Stroke属性,而如果需要进行填充,则需要所有的线条绘制完成之后才能进行填充或者默认填充。看PathView的源码:1234567891011121314151617181920212223242526272829303132@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if(mTempBitmap==null || (mTempBitmap.getWidth()!=canvas.getWidth()||mTempBitmap.getHeight()!=canvas.getHeight()) ) &#123; mTempBitmap = Bitmap.createBitmap(canvas.getWidth(), canvas.getHeight(), Bitmap.Config.ARGB_8888); mTempCanvas = new Canvas(mTempBitmap); &#125; mTempBitmap.eraseColor(0); synchronized (mSvgLock) &#123; mTempCanvas.save(); mTempCanvas.translate(getPaddingLeft(), getPaddingTop()); fill(mTempCanvas);//直接进行填充 final int count = paths.size(); for (int i = 0; i &lt; count; i++) &#123; final SvgUtils.SvgPath svgPath = paths.get(i); final Path path = svgPath.path; final Paint paint1 = naturalColors ? svgPath.paint : paint; mTempCanvas.drawPath(path, paint1); &#125; fillAfter(mTempCanvas);//线条绘制完成之后 在进行填充 mTempCanvas.restore(); applySolidColor(mTempBitmap); canvas.drawBitmap(mTempBitmap,0,0,null); &#125;&#125; 其实这里选Stroke属性还是Fill属性都是看svg的情况而定,针对于我自己做的这个svg图，我对比了三种属性的不同效果,看图:看了上图我们可以发现,如果我们使用的svg不是由单线条组成的,会感觉特别怪异,而Fill和Fill And Stroke则显示的较为舒服。更贴近svg在浏览器显示出来的效果。那么问题来了！ 如果我们使用Fill 属性或者Fill And Stroke属性，在线条绘制过程中会把所截取的Path的起点和重点连接起来形成一个闭合区域。我把这种情况叫做“绘制过度”（瞎取的），看图： 为什么会导致这种情况看我画的这张图你就会明白了； 在path往回绘制的时候，paint并不知道接下来会如何填充，所以就直接连接了迂回点和终点。 那么如何消除Fill属性带来的影响呢？刚开始我想了大致两个思路并进行了尝试： 多保留一份Paths，在绘制的时候Clip原path路径。 多保留一份Paths，使用PorterDuffXfermode，当绘制的时候显示被绘制的path遮挡的部分。 我先实现了思路1，看我如何实现的：1234567891011121314151617181920212223@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int sc = canvas.save(Canvas.ALL_SAVE_FLAG); synchronized (mSvgLock) &#123; int count = mPaths.size(); for (int i = 0; i &lt; count; i++) &#123; int pc = canvas.save(Canvas.ALL_SAVE_FLAG); //需要备用一个完整的path路径，来修复pathPaint的Fill造成绘制过度 Path path = pathLayer.mDrawer.get(i);//这个pathLayer 指的就是Pathview中的SvgUtils canvas.clipPath(path); PathLayer.SvgPath svgPath = mPaths.get(i); canvas.drawPath(svgPath.path, pathPaint); canvas.restoreToCount(pc); &#125; &#125; canvas.restoreToCount(sc); for (PathLayer.SvgPath svgPath : mPaths) &#123; if (isDrawing &amp;&amp; svgPath.isMeasure) &#123;//过滤初始为0的点 canvas.drawBitmap(paintLayer, svgPath.point[0] - nibPointf.x, svgPath.point[1] - nibPointf.y, null); &#125; &#125; &#125; 看效果： 仔细看效果发现其实还是有问题存在的，再线条迂回的地方会把遗漏； 为什么会导致这种情况,其实还是前面讲到过的绘制过度。于是我尝试了下实现下思路2：12345678910111213141516171819202122232425private PorterDuffXfermode xfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT);@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int sc = canvas.save(Canvas.ALL_SAVE_FLAG); synchronized (mSvgLock) &#123; int count = mPaths.size(); for (int i = 0; i &lt; count; i++) &#123; int pc = canvas.save(Canvas.ALL_SAVE_FLAG); PathLayer.SvgPath svgPath = mPaths.get(i); if (isFill) &#123; //需要备用一个完整的path路径，来修复pathPaint的Fill造成绘制过度 Path path = pathLayer.mDrawer.get(i); canvas.clipPath(path); if (isDrawing &amp;&amp; svgPath.isMeasure) &#123; canvas.drawPath(path, drawerPaint); &#125; &#125; canvas.drawPath(svgPath.path, pathPaint); canvas.restoreToCount(pc); &#125; &#125; canvas.restoreToCount(sc);&#125; 效果如下： 关于为什么要使用PorterDuff.Mode.SRC_OUT，其实我是试出来的0.0，本以为这样就完美了，但是我发现当仔细看发现颜色他么怎么变成黑色了（我用的是灰色）！！！然后我尝试了使用一张Bitmap的Canvas来代替view的Canvas再渲染像素点的颜色的时候，发现效果又乱了！！！！真是奇怪，为了研究原因我将 canvas.clipPath(path);去掉，发现了新大陆,看图： 原来PorterDuff.Mode.SRC_OUT将非覆盖面生成了矩形块，那么新思路就有了：3.直接截取path的矩形块：1234567if (isFill) &#123; //需要备用一个完整的path路径，来修复pathPaint的Fill造成绘制过度 Path path = pathLayer.mDrawer.get(i); canvas.clipPath(path); svgPath.path.computeBounds(drawRect, true); canvas.drawRect(drawRect, drawerPaint); &#125; 最终效果图就和文章最开始的显示效果一致了,哈哈 几经波折终于出现好效果啦! 如何制作svg关于如何制作成这样的svg ，你可以考虑看我的文章：《如何将图片生成svg》，使用的是Adobe Illustrator而不是GMIP2 最后，如果你喜欢或者有何意见，不妨Star或者给我提Issuses哦！项目地址","text":"先上图： 点子来自于一次情人节的礼物思考，想着能不能不俗套的去送花发红包之类的，再加上妹子也是做技术的，所以就想着搞了一个这个。 这个效果的原理是基于PathView的，可是PathView并不能满足我的需求，于是乎我就开始下手自己修改了。 下面我会一边分析PathView的实现过程，一边描述我是如何修改的(GIF图很多小心流量)。如果你不想看的话项目地址在这https://github.com/MartinBZDQSM/PathDraw 动画效果如果你了解PathView的动画的话，你就知道它的动画分为两种情况1.getPathAnimator 并行效果2.getSequentialPathAnimator 顺序效果如果你想知道它的实现原理建议查看PathView当中的两个静态内部类AnimatorBuilder和AnimatorSetBuilder。但是当我使用AnimatorSetBuilder 进行顺序绘制的时候我发现效果其实并不好，为什么不好哪里不好呢？看它的源码：1234567891011/** * Sets the duration of the animation. Since the AnimatorSet sets the duration for each * Animator, we have to divide it by the number of paths. * * @param duration - The duration of the animation. * @return AnimatorSetBuilder. */ public AnimatorSetBuilder duration(final int duration) &#123; this.duration = duration / paths.size(); return this; &#125; 看完以上代码你就会知道PathView的作者计算出来的动画时间是你设置的平均时间，也就是说不管我这条path的路径到底有多长，所有path的执行时间都是一样的。那我画一个点和画一条直线的时间都是一样的是不是有点扯？所以我在这里增加了平均时间的计算，根据计算path的长度在总长度中的占比，然后单个设置时间,进行顺序轮播,我也试过使用AnimatorSet单独设置Animator的时间,但是好像并没有效果,所以我用比较蠢点方法进行了实现，大致修改的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * Default constructor. * * @param pathView The view that must be animated. */public AnimatorSetBuilder(final PathDrawingView pathView) &#123; paths = pathView.mPaths; if (pathViewAnimatorListener == null) &#123; pathViewAnimatorListener = new PathViewAnimatorListener(); &#125; for (PathLayer.SvgPath path : paths) &#123; path.setAnimationStepListener(pathView); ObjectAnimator animation = ObjectAnimator.ofFloat(path, \"length\", 0.0f, path.getLength()); totalLenth = totalLenth + path.getLength(); animators.add(animation); &#125; for (int i = 0; i &lt; paths.size(); i++) &#123; long animationDuration = (long) (paths.get(i).getLength() * duration / totalLenth); Animator animator = animators.get(i); animator.setStartDelay(delay); animator.setDuration(animationDuration); animator.addListener(pathViewAnimatorListener); &#125;&#125;/** * Starts the animation. */public void start() &#123; resetAllPaths(); for (Animator animator : animators) &#123; animator.cancel(); &#125; index = 0; startAnimatorByIndex();&#125;public void startAnimatorByIndex() &#123; if (index &gt;= paths.size()) &#123; return; &#125; Animator animator = animators.get(index); animator.start();&#125;/** * Sets the length of all the paths to 0. */private void resetAllPaths() &#123; for (PathLayer.SvgPath path : paths) &#123; path.setLength(0); &#125;&#125;/** * Called when the animation start. */public interface ListenerStart &#123; /** * Called when the path animation start. */ void onAnimationStart();&#125;/** * Called when the animation end. */public interface ListenerEnd &#123; /** * Called when the path animation end. */ void onAnimationEnd();&#125;/** * Animation listener to be able to provide callbacks for the caller. */private class PathViewAnimatorListener implements Animator.AnimatorListener &#123; @Override public void onAnimationStart(Animator animation) &#123; if (index &lt; paths.size() - 1) &#123; paths.get(index).isMeasure = true; PathDrawingView.isDrawing = true; if (index == 0 &amp;&amp; listenerStart != null) listenerStart.onAnimationStart(); &#125; &#125; @Override public void onAnimationEnd(Animator animation) &#123; if (index &gt;= paths.size() - 1) &#123; PathDrawingView.isDrawing = false; if (animationEnd != null) animationEnd.onAnimationEnd(); &#125; else &#123; if (index &lt; paths.size() - 1) &#123; paths.get(index).isMeasure = false; index++; startAnimatorByIndex(); &#125; &#125; &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125;&#125; 画笔动态跟踪PathView中线条渐变是通过截取path当中的片段做成的，看码:1234567891011121314/** * Sets the length of the path. * * @param length The length to be set. */ public void setLength(float length) &#123; path.reset(); measure.getSegment(0.0f, length, path, true); path.rLineTo(0.0f, 0.0f); if (animationStepListener != null) &#123; animationStepListener.onAnimationStep(); &#125; &#125; 既然动画的原理是通过改变截取的长度做到的，那么只要能获取到截取长度最后的那个点是不是就可以充当轨迹了？所以这里只需要添加一个锚点，每当截取长度变化的时候，锚点也跟着改变,看代码：123456789public void setLength(float length) &#123; path.reset(); measure.getSegment(0.0f, length, path, true); measure.getPosTan(length, point, null);//跟踪锚点 path.rLineTo(0.0f, 0.0f); if (animationStepListener != null) &#123; animationStepListener.onAnimationStep(); &#125; &#125; 笔尖移动的原理，需要提前计算好笔尖在画笔图片中的坐标，然后对照着锚点进行移动就行了。Tips:这里我的画笔图片还没有针对画布宽高进行缩放，所以在不同分辨率的情况下画笔显示的大小可能是不一致的。 我认知的FillPathView中对于Path的Paint选的是Stroke属性,而如果需要进行填充,则需要所有的线条绘制完成之后才能进行填充或者默认填充。看PathView的源码:1234567891011121314151617181920212223242526272829303132@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if(mTempBitmap==null || (mTempBitmap.getWidth()!=canvas.getWidth()||mTempBitmap.getHeight()!=canvas.getHeight()) ) &#123; mTempBitmap = Bitmap.createBitmap(canvas.getWidth(), canvas.getHeight(), Bitmap.Config.ARGB_8888); mTempCanvas = new Canvas(mTempBitmap); &#125; mTempBitmap.eraseColor(0); synchronized (mSvgLock) &#123; mTempCanvas.save(); mTempCanvas.translate(getPaddingLeft(), getPaddingTop()); fill(mTempCanvas);//直接进行填充 final int count = paths.size(); for (int i = 0; i &lt; count; i++) &#123; final SvgUtils.SvgPath svgPath = paths.get(i); final Path path = svgPath.path; final Paint paint1 = naturalColors ? svgPath.paint : paint; mTempCanvas.drawPath(path, paint1); &#125; fillAfter(mTempCanvas);//线条绘制完成之后 在进行填充 mTempCanvas.restore(); applySolidColor(mTempBitmap); canvas.drawBitmap(mTempBitmap,0,0,null); &#125;&#125; 其实这里选Stroke属性还是Fill属性都是看svg的情况而定,针对于我自己做的这个svg图，我对比了三种属性的不同效果,看图:看了上图我们可以发现,如果我们使用的svg不是由单线条组成的,会感觉特别怪异,而Fill和Fill And Stroke则显示的较为舒服。更贴近svg在浏览器显示出来的效果。那么问题来了！ 如果我们使用Fill 属性或者Fill And Stroke属性，在线条绘制过程中会把所截取的Path的起点和重点连接起来形成一个闭合区域。我把这种情况叫做“绘制过度”（瞎取的），看图： 为什么会导致这种情况看我画的这张图你就会明白了； 在path往回绘制的时候，paint并不知道接下来会如何填充，所以就直接连接了迂回点和终点。 那么如何消除Fill属性带来的影响呢？刚开始我想了大致两个思路并进行了尝试： 多保留一份Paths，在绘制的时候Clip原path路径。 多保留一份Paths，使用PorterDuffXfermode，当绘制的时候显示被绘制的path遮挡的部分。 我先实现了思路1，看我如何实现的：1234567891011121314151617181920212223@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int sc = canvas.save(Canvas.ALL_SAVE_FLAG); synchronized (mSvgLock) &#123; int count = mPaths.size(); for (int i = 0; i &lt; count; i++) &#123; int pc = canvas.save(Canvas.ALL_SAVE_FLAG); //需要备用一个完整的path路径，来修复pathPaint的Fill造成绘制过度 Path path = pathLayer.mDrawer.get(i);//这个pathLayer 指的就是Pathview中的SvgUtils canvas.clipPath(path); PathLayer.SvgPath svgPath = mPaths.get(i); canvas.drawPath(svgPath.path, pathPaint); canvas.restoreToCount(pc); &#125; &#125; canvas.restoreToCount(sc); for (PathLayer.SvgPath svgPath : mPaths) &#123; if (isDrawing &amp;&amp; svgPath.isMeasure) &#123;//过滤初始为0的点 canvas.drawBitmap(paintLayer, svgPath.point[0] - nibPointf.x, svgPath.point[1] - nibPointf.y, null); &#125; &#125; &#125; 看效果： 仔细看效果发现其实还是有问题存在的，再线条迂回的地方会把遗漏； 为什么会导致这种情况,其实还是前面讲到过的绘制过度。于是我尝试了下实现下思路2：12345678910111213141516171819202122232425private PorterDuffXfermode xfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT);@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int sc = canvas.save(Canvas.ALL_SAVE_FLAG); synchronized (mSvgLock) &#123; int count = mPaths.size(); for (int i = 0; i &lt; count; i++) &#123; int pc = canvas.save(Canvas.ALL_SAVE_FLAG); PathLayer.SvgPath svgPath = mPaths.get(i); if (isFill) &#123; //需要备用一个完整的path路径，来修复pathPaint的Fill造成绘制过度 Path path = pathLayer.mDrawer.get(i); canvas.clipPath(path); if (isDrawing &amp;&amp; svgPath.isMeasure) &#123; canvas.drawPath(path, drawerPaint); &#125; &#125; canvas.drawPath(svgPath.path, pathPaint); canvas.restoreToCount(pc); &#125; &#125; canvas.restoreToCount(sc);&#125; 效果如下： 关于为什么要使用PorterDuff.Mode.SRC_OUT，其实我是试出来的0.0，本以为这样就完美了，但是我发现当仔细看发现颜色他么怎么变成黑色了（我用的是灰色）！！！然后我尝试了使用一张Bitmap的Canvas来代替view的Canvas再渲染像素点的颜色的时候，发现效果又乱了！！！！真是奇怪，为了研究原因我将 canvas.clipPath(path);去掉，发现了新大陆,看图： 原来PorterDuff.Mode.SRC_OUT将非覆盖面生成了矩形块，那么新思路就有了：3.直接截取path的矩形块：1234567if (isFill) &#123; //需要备用一个完整的path路径，来修复pathPaint的Fill造成绘制过度 Path path = pathLayer.mDrawer.get(i); canvas.clipPath(path); svgPath.path.computeBounds(drawRect, true); canvas.drawRect(drawRect, drawerPaint); &#125; 最终效果图就和文章最开始的显示效果一致了,哈哈 几经波折终于出现好效果啦! 如何制作svg关于如何制作成这样的svg ，你可以考虑看我的文章：《如何将图片生成svg》，使用的是Adobe Illustrator而不是GMIP2 最后，如果你喜欢或者有何意见，不妨Star或者给我提Issuses哦！项目地址 ]","categories":[{"name":"Android","slug":"Android","permalink":"https://martinbzdqsm.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://martinbzdqsm.github.io/tags/android/"},{"name":"matrix","slug":"matrix","permalink":"https://martinbzdqsm.github.io/tags/matrix/"},{"name":"canvas","slug":"canvas","permalink":"https://martinbzdqsm.github.io/tags/canvas/"},{"name":"svg","slug":"svg","permalink":"https://martinbzdqsm.github.io/tags/svg/"}]},{"title":"利用Matrix让蝴蝶动起来","slug":"利用Matrix让蝴蝶动起来","date":"2017-01-16T07:53:35.000Z","updated":"2017-02-04T05:43:10.091Z","comments":true,"path":"2017/01/16/利用Matrix让蝴蝶动起来/","link":"","permalink":"https://martinbzdqsm.github.io/2017/01/16/利用Matrix让蝴蝶动起来/","excerpt":"有幸在鸿洋的一篇Android FoldingLayout 折叠布局 原理及实现（一）中，学习到了Matrix的setPolyToPoly操作，于是着想到了如何让一张静态的蝴蝶图片动起来。先上图：项目地址，gif有点掉帧，完整效果直接把项目clone下来试试就行了。 整体思路由三个部分组成：1.蝴蝶的绘制。2.折叠动画。3.细节抖动。 下面大概描述一下实现过程： 蝴蝶的绘制蝴蝶的绘制使用的是svg+图片融合PorterDuffXfermode，对 这并不是一张图片，也就是说蝴蝶上的花纹是可以随意变化的。在布局中添加花纹代码如下：123456&lt;com.martin.butterfly.master.ButterFlyLoadView android:id=\"@+id/mbutterfly_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:figure=\"@drawable/figure1\" /&gt; 关于svg的转化我并没有使用常见的解析方式；而是使用的是SVG2Drawable,去除了关于svg的解析过程，直接使用生成后的path代码。在组件初始化的时候使用PorterDuffXfermode生成相关花纹的蝴蝶图片。 折叠动画折叠的原理还是跟文章头部所说到的Android FoldingLayout 折叠布局 原理及实现（一）与其原理一致，主要判断好两支翅膀的矩形块与ToPoly的变化，这里不再复述了，如果需要了解该api的话可以去看看鸿洋的博客，我将这些变化都封装在ButterFlyDrawable中方便更改视图效果，并不仅仅使用在dialog之中。动的更逼真点。","text":"有幸在鸿洋的一篇Android FoldingLayout 折叠布局 原理及实现（一）中，学习到了Matrix的setPolyToPoly操作，于是着想到了如何让一张静态的蝴蝶图片动起来。先上图：项目地址，gif有点掉帧，完整效果直接把项目clone下来试试就行了。 整体思路由三个部分组成：1.蝴蝶的绘制。2.折叠动画。3.细节抖动。 下面大概描述一下实现过程： 蝴蝶的绘制蝴蝶的绘制使用的是svg+图片融合PorterDuffXfermode，对 这并不是一张图片，也就是说蝴蝶上的花纹是可以随意变化的。在布局中添加花纹代码如下：123456&lt;com.martin.butterfly.master.ButterFlyLoadView android:id=\"@+id/mbutterfly_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:figure=\"@drawable/figure1\" /&gt; 关于svg的转化我并没有使用常见的解析方式；而是使用的是SVG2Drawable,去除了关于svg的解析过程，直接使用生成后的path代码。在组件初始化的时候使用PorterDuffXfermode生成相关花纹的蝴蝶图片。 折叠动画折叠的原理还是跟文章头部所说到的Android FoldingLayout 折叠布局 原理及实现（一）与其原理一致，主要判断好两支翅膀的矩形块与ToPoly的变化，这里不再复述了，如果需要了解该api的话可以去看看鸿洋的博客，我将这些变化都封装在ButterFlyDrawable中方便更改视图效果，并不仅仅使用在dialog之中。动的更逼真点。如果你喜欢这个动画的话，欢迎点赞和star","categories":[{"name":"Android","slug":"Android","permalink":"https://martinbzdqsm.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://martinbzdqsm.github.io/tags/android/"},{"name":"matrix","slug":"matrix","permalink":"https://martinbzdqsm.github.io/tags/matrix/"},{"name":"canvas","slug":"canvas","permalink":"https://martinbzdqsm.github.io/tags/canvas/"}]},{"title":"列表视差效果","slug":"列表视差效果","date":"2017-01-16T07:51:41.000Z","updated":"2017-02-09T09:30:03.433Z","comments":true,"path":"2017/01/16/列表视差效果/","link":"","permalink":"https://martinbzdqsm.github.io/2017/01/16/列表视差效果/","excerpt":"ParallaxScrollImageView 这个控件是做什么的呢？如标题 主要是用于ListView 和RecyclerView中图片的滚动差效果。之前接到这个需求的时候，顺便到网上查了查，发现千篇一律的全是ListView头部的视图滚动差效果，我就想不明白了，他们怎么就取个名字叫做“Parallax ListView”了，加个“head”又不会怎么样，也只好自己动手了。具体的效果如下图： 没看出效果的,可以下载apk体验一下: https://yunpan.cn/c6yFmtfD9cAyL 访问密码 469d 实现流程：图片的偏移：图片的偏移，采用的是Canvas的Matrix Translate操作，具体需要计算的参照物如图显示： 通过提前设置好组件显示的宽高比来计算出‘图片显示区域’和’真实图片区域’的偏差值，再计算距离中线的距离来计算滑动距离，这样item在滚动时不同组件的高度与中线的距离不同，即产生落差。 12345 if (orientation == Orientation.BOTTOM_TOP) &#123; localMatrix.postTranslate(0.0F, (-(targetDis / 2) - (((targetHeight - screenHeight / 2)) * targetDis) / screenHeight));&#125; else &#123; localMatrix.postTranslate(0.0F,(-(targetDis / 2) + (((targetHeight - screenHeight / 2)) * targetDis) / screenHeight));&#125; 视图的滚动/组件的刷新：视图的滚动主要是依靠监听Listview 和RecyclerView的滑动事件做到的，因为组件无法知道自己在列表中什么时候会进行滑动，所以需要监听器进行通知，我在组件中写了一个公开方法1public void doWork() &#123; invalidate();&#125; 而监听器的方法与我们做滑动底部刷新的方法一致，主要是要知道当前在屏幕的的item的数量与坐标，listview 的很简单，这个在网上查一查就知道了。而RecyclerView中由于不同类型的LinearManage获取数量与坐标的方法也有不同，下面来举出：123456789101112131415161718192021222324252627282930@Overridepublic void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); int firstVisibleItem = 0, visibleItemCount = 0; if (GridLayoutManager.class.isInstance(layoutManager)) &#123; //格子 firstVisibleItem = ((GridLayoutManager) layoutManager).findFirstVisibleItemPosition(); visibleItemCount = ((GridLayoutManager) layoutManager).findLastVisibleItemPosition() - firstVisibleItem + 1; &#125; else if (StaggeredGridLayoutManager.class.isInstance(layoutManager)) &#123;//瀑布流 StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager) layoutManager; int[] firstVisibleItems = (staggeredGridLayoutManager).findFirstVisibleItemPositions(new int[staggeredGridLayoutManager.getSpanCount()]); int[] lastVisibleItems = (staggeredGridLayoutManager).findLastVisibleItemPositions(new int[staggeredGridLayoutManager.getSpanCount()]); visibleItemCount = getMaxPosition(lastVisibleItems) - getMinPosition(firstVisibleItems); &#125; else if (LinearLayoutManager.class.isInstance(layoutManager)) &#123; //线性 firstVisibleItem = ((LinearLayoutManager) layoutManager).findFirstVisibleItemPosition(); visibleItemCount = ((LinearLayoutManager) layoutManager).findLastVisibleItemPosition() - firstVisibleItem + 1; &#125; for (int i = 0, count = visibleItemCount; i &lt; count; ++i) &#123; try &#123; ParallaxImageView currentImageView = (ParallaxImageView) recyclerView.getChildAt(i).findViewById(parallaxImageViewId); currentImageView.doWork(); //刷新组件 &#125; catch (NullPointerException e) &#123; &#125; &#125;&#125; 如何使用：添加库Step 1. 在你工程的根build.gradle下面添加对仓库的描述:123456allprojects &#123; repositories &#123; ... maven &#123; url \"https://jitpack.io\" &#125; &#125;&#125; Step 2. 添加描述123dependencies &#123; compile 'com.github.MartinBZDQSM:ParallaxScrollImageView:v1.0'&#125; tips: If you already used the appcompat-v7 and recyclerview-v7 try this：1234567compile 'com.android.support:appcompat-v7:' + SUPPORT_VERSION compile 'com.android.support:recyclerview-v7:' + SUPPORT_VERSION compile('com.github.MartinBZDQSM:ParallaxScrollImageView:v1.0') &#123;exclude group: 'com.android.support', module: 'appcompat-v7' exclude group: 'com.android.support', module: 'recyclerview-v7'&#125; 如何用?在布局文件中添加ParallaxImageView 并添加相关参数:12345678&lt;martinbzdqsm.com.parallaxscrollimageview_master.ParallaxImageView xmlns:parallax=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/img\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" parallax:img_ratio=\"0.6\" parallax:orientation=\"bottom_top\" parallax:paralax_ratio=\"0.2\" /&gt; parallax:img_ratio ：图片预览时所呈现的高与实际宽度的比值 parallax:paralax_ratio：图片预览时偏移距离与实际宽度的比值 所以 img_ratio+paralax_ratio= height(实际高度)/width(实际宽度) parallax:orientation ： TOP_BOTTOM,BOTTOM_TOP 添加滑动监控器: Listview ： parallaxListViewController = new ParallaxListViewController(R.id.img); listView.setOnScrollListener(parallaxListViewController); Recylerview: (GridLayoutManager,StaggeredGridLayoutManager,LinearLayoutManager) GridLayoutManager gridLayoutManager = new GridLayoutManager(this,2); mParallaxRecyclerViewController = new ParallaxRecyclerViewController(gridLayoutManager, R.id.img); mRecyclerView.setLayoutManager(gridLayoutManager); mRecyclerView.addOnScrollListener(mParallaxRecyclerViewController); mRecyclerView.setAdapter(recyclerViewAdapter); Tips: StaggeredGridLayoutManager 瀑布流与其他的用法稍微有点不同,如果有需要可以看下demo如何写的。","text":"ParallaxScrollImageView 这个控件是做什么的呢？如标题 主要是用于ListView 和RecyclerView中图片的滚动差效果。之前接到这个需求的时候，顺便到网上查了查，发现千篇一律的全是ListView头部的视图滚动差效果，我就想不明白了，他们怎么就取个名字叫做“Parallax ListView”了，加个“head”又不会怎么样，也只好自己动手了。具体的效果如下图： 没看出效果的,可以下载apk体验一下: https://yunpan.cn/c6yFmtfD9cAyL 访问密码 469d 实现流程：图片的偏移：图片的偏移，采用的是Canvas的Matrix Translate操作，具体需要计算的参照物如图显示： 通过提前设置好组件显示的宽高比来计算出‘图片显示区域’和’真实图片区域’的偏差值，再计算距离中线的距离来计算滑动距离，这样item在滚动时不同组件的高度与中线的距离不同，即产生落差。 12345 if (orientation == Orientation.BOTTOM_TOP) &#123; localMatrix.postTranslate(0.0F, (-(targetDis / 2) - (((targetHeight - screenHeight / 2)) * targetDis) / screenHeight));&#125; else &#123; localMatrix.postTranslate(0.0F,(-(targetDis / 2) + (((targetHeight - screenHeight / 2)) * targetDis) / screenHeight));&#125; 视图的滚动/组件的刷新：视图的滚动主要是依靠监听Listview 和RecyclerView的滑动事件做到的，因为组件无法知道自己在列表中什么时候会进行滑动，所以需要监听器进行通知，我在组件中写了一个公开方法1public void doWork() &#123; invalidate();&#125; 而监听器的方法与我们做滑动底部刷新的方法一致，主要是要知道当前在屏幕的的item的数量与坐标，listview 的很简单，这个在网上查一查就知道了。而RecyclerView中由于不同类型的LinearManage获取数量与坐标的方法也有不同，下面来举出：123456789101112131415161718192021222324252627282930@Overridepublic void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); int firstVisibleItem = 0, visibleItemCount = 0; if (GridLayoutManager.class.isInstance(layoutManager)) &#123; //格子 firstVisibleItem = ((GridLayoutManager) layoutManager).findFirstVisibleItemPosition(); visibleItemCount = ((GridLayoutManager) layoutManager).findLastVisibleItemPosition() - firstVisibleItem + 1; &#125; else if (StaggeredGridLayoutManager.class.isInstance(layoutManager)) &#123;//瀑布流 StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager) layoutManager; int[] firstVisibleItems = (staggeredGridLayoutManager).findFirstVisibleItemPositions(new int[staggeredGridLayoutManager.getSpanCount()]); int[] lastVisibleItems = (staggeredGridLayoutManager).findLastVisibleItemPositions(new int[staggeredGridLayoutManager.getSpanCount()]); visibleItemCount = getMaxPosition(lastVisibleItems) - getMinPosition(firstVisibleItems); &#125; else if (LinearLayoutManager.class.isInstance(layoutManager)) &#123; //线性 firstVisibleItem = ((LinearLayoutManager) layoutManager).findFirstVisibleItemPosition(); visibleItemCount = ((LinearLayoutManager) layoutManager).findLastVisibleItemPosition() - firstVisibleItem + 1; &#125; for (int i = 0, count = visibleItemCount; i &lt; count; ++i) &#123; try &#123; ParallaxImageView currentImageView = (ParallaxImageView) recyclerView.getChildAt(i).findViewById(parallaxImageViewId); currentImageView.doWork(); //刷新组件 &#125; catch (NullPointerException e) &#123; &#125; &#125;&#125; 如何使用：添加库Step 1. 在你工程的根build.gradle下面添加对仓库的描述:123456allprojects &#123; repositories &#123; ... maven &#123; url \"https://jitpack.io\" &#125; &#125;&#125; Step 2. 添加描述123dependencies &#123; compile 'com.github.MartinBZDQSM:ParallaxScrollImageView:v1.0'&#125; tips: If you already used the appcompat-v7 and recyclerview-v7 try this：1234567compile 'com.android.support:appcompat-v7:' + SUPPORT_VERSION compile 'com.android.support:recyclerview-v7:' + SUPPORT_VERSION compile('com.github.MartinBZDQSM:ParallaxScrollImageView:v1.0') &#123;exclude group: 'com.android.support', module: 'appcompat-v7' exclude group: 'com.android.support', module: 'recyclerview-v7'&#125; 如何用?在布局文件中添加ParallaxImageView 并添加相关参数:12345678&lt;martinbzdqsm.com.parallaxscrollimageview_master.ParallaxImageView xmlns:parallax=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/img\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" parallax:img_ratio=\"0.6\" parallax:orientation=\"bottom_top\" parallax:paralax_ratio=\"0.2\" /&gt; parallax:img_ratio ：图片预览时所呈现的高与实际宽度的比值 parallax:paralax_ratio：图片预览时偏移距离与实际宽度的比值 所以 img_ratio+paralax_ratio= height(实际高度)/width(实际宽度) parallax:orientation ： TOP_BOTTOM,BOTTOM_TOP 添加滑动监控器: Listview ： parallaxListViewController = new ParallaxListViewController(R.id.img); listView.setOnScrollListener(parallaxListViewController); Recylerview: (GridLayoutManager,StaggeredGridLayoutManager,LinearLayoutManager) GridLayoutManager gridLayoutManager = new GridLayoutManager(this,2); mParallaxRecyclerViewController = new ParallaxRecyclerViewController(gridLayoutManager, R.id.img); mRecyclerView.setLayoutManager(gridLayoutManager); mRecyclerView.addOnScrollListener(mParallaxRecyclerViewController); mRecyclerView.setAdapter(recyclerViewAdapter); Tips: StaggeredGridLayoutManager 瀑布流与其他的用法稍微有点不同,如果有需要可以看下demo如何写的。 项目地址https://github.com/MartinBZDQSM/ParallaxScrollImageView#","categories":[{"name":"Android","slug":"Android","permalink":"https://martinbzdqsm.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://martinbzdqsm.github.io/tags/android/"},{"name":"matrix","slug":"matrix","permalink":"https://martinbzdqsm.github.io/tags/matrix/"},{"name":"canvas","slug":"canvas","permalink":"https://martinbzdqsm.github.io/tags/canvas/"}]},{"title":"图片线条化","slug":"图片线条化","date":"2017-01-16T07:49:08.000Z","updated":"2017-01-16T12:52:47.787Z","comments":true,"path":"2017/01/16/图片线条化/","link":"","permalink":"https://martinbzdqsm.github.io/2017/01/16/图片线条化/","excerpt":"工具：Photoshop 流程1.准备一张图片2.将原图ps成线条画：将图片在ps中打开，然后ctrl+j 复制一张图层，按住ctrl+shirft+u进行去色。然后选中去掉色的图层： 再按ctrl+j 复制一张图层，按住ctrl+i 进行反相 调整混合模式为颜色减淡，滤镜菜单下选择其他里的最小值滤镜，你自己把控下力度！","text":"工具：Photoshop 流程1.准备一张图片2.将原图ps成线条画：将图片在ps中打开，然后ctrl+j 复制一张图层，按住ctrl+shirft+u进行去色。然后选中去掉色的图层： 再按ctrl+j 复制一张图层，按住ctrl+i 进行反相 调整混合模式为颜色减淡，滤镜菜单下选择其他里的最小值滤镜，你自己把控下力度！","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://martinbzdqsm.github.io/categories/杂七杂八/"}],"tags":[{"name":"ps","slug":"ps","permalink":"https://martinbzdqsm.github.io/tags/ps/"},{"name":"adobe","slug":"adobe","permalink":"https://martinbzdqsm.github.io/tags/adobe/"}]},{"title":"图像转Svg","slug":"图像转svg","date":"2017-01-15T15:33:57.000Z","updated":"2017-01-16T12:54:00.885Z","comments":true,"path":"2017/01/15/图像转svg/","link":"","permalink":"https://martinbzdqsm.github.io/2017/01/15/图像转svg/","excerpt":"工具：Adobe Illustrator 流程之前了解到的勾勒svg路径的工具可能用的比较多的都是GIMP 2,当我问到我司的美工大大的时候，他介绍我Adobe Illustrator 这个流弊哄哄的工具。使用起来超级简单：1.在AI中打开需要处理的图片（下方图只是演示，并不是叫你使用处理过的图，你随意就好了。），然后点击上方的图像临摹按钮：2.调节右方属性中的阈值，调节到你想用的效果 然后点击上方的扩展按钮，并保存成svg，=","text":"工具：Adobe Illustrator 流程之前了解到的勾勒svg路径的工具可能用的比较多的都是GIMP 2,当我问到我司的美工大大的时候，他介绍我Adobe Illustrator 这个流弊哄哄的工具。使用起来超级简单：1.在AI中打开需要处理的图片（下方图只是演示，并不是叫你使用处理过的图，你随意就好了。），然后点击上方的图像临摹按钮：2.调节右方属性中的阈值，调节到你想用的效果 然后点击上方的扩展按钮，并保存成svg，=","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://martinbzdqsm.github.io/categories/杂七杂八/"}],"tags":[{"name":"ps","slug":"ps","permalink":"https://martinbzdqsm.github.io/tags/ps/"},{"name":"adobe","slug":"adobe","permalink":"https://martinbzdqsm.github.io/tags/adobe/"}]}]}