{"meta":{"title":"Martin Blog","subtitle":"记录编程的点滴","description":"记录编程的点滴","author":"Martin","url":"https://martinbzdqsm.github.io"},"pages":[{"title":"about","date":"2017-01-16T06:01:31.000Z","updated":"2017-01-16T06:01:31.885Z","comments":true,"path":"about/index.html","permalink":"https://martinbzdqsm.github.io/about/index.html","excerpt":"","text":""},{"title":"gallery","date":"2017-01-16T10:41:03.000Z","updated":"2017-01-16T10:41:03.210Z","comments":true,"path":"gallery/index.html","permalink":"https://martinbzdqsm.github.io/gallery/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-01-16T06:00:27.000Z","updated":"2017-01-16T06:02:22.638Z","comments":false,"path":"categories/index.html","permalink":"https://martinbzdqsm.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-01-16T04:57:20.000Z","updated":"2017-01-16T06:13:12.457Z","comments":true,"path":"tags/index.html","permalink":"https://martinbzdqsm.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"利用Matrix让蝴蝶动起来","slug":"利用Matrix让蝴蝶动起来","date":"2017-01-16T07:53:35.000Z","updated":"2017-01-16T10:46:31.674Z","comments":true,"path":"2017/01/16/利用Matrix让蝴蝶动起来/","link":"","permalink":"https://martinbzdqsm.github.io/2017/01/16/利用Matrix让蝴蝶动起来/","excerpt":"有幸在鸿洋的一篇Android FoldingLayout 折叠布局 原理及实现（一）中，学习到了Matrix的setPolyToPoly操作，于是着想到了如何实现这样一个的动画效果。先上图：项目地址，gif有点掉帧，完整效果直接把项目clone下来试试就行了。 整体思路由三个部分组成：1.蝴蝶的绘制。2.折叠动画。3.细节抖动。 下面大概描述一下实现过程：","text":"有幸在鸿洋的一篇Android FoldingLayout 折叠布局 原理及实现（一）中，学习到了Matrix的setPolyToPoly操作，于是着想到了如何实现这样一个的动画效果。先上图：项目地址，gif有点掉帧，完整效果直接把项目clone下来试试就行了。 整体思路由三个部分组成：1.蝴蝶的绘制。2.折叠动画。3.细节抖动。 下面大概描述一下实现过程： 蝴蝶的绘制蝴蝶的绘制使用的是svg+图片融合PorterDuffXfermode，对 这并不是一张图片，也就是说蝴蝶上的花纹是可以随意变化的。在布局中添加花纹代码如下：123456&lt;com.martin.butterfly.master.ButterFlyLoadView android:id=\"@+id/mbutterfly_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:figure=\"@drawable/figure1\" /&gt; 关于svg的转化我并没有使用常见的解析方式；而是使用的是SVG2Drawable,去除了关于svg的解析过程，直接使用生成后的path代码。在组件初始化的时候使用PorterDuffXfermode生成相关花纹的蝴蝶图片。 折叠动画折叠的原理还是跟文章头部所说到的Android FoldingLayout 折叠布局 原理及实现（一）与其原理一致，主要判断好两支翅膀的矩形块与ToPoly的变化，这里不再复述了，如果需要了解该api的话可以去看看鸿洋的博客，我将这些变化都封装在ButterFlyDrawable中方便更改视图效果，并不仅仅使用在dialog之中。 细节抖动如果仅仅是蝴蝶扇翅膀，我觉得不怎么生动，为此我还增加细节抖动，使蝴蝶扇动的更逼真点。 如果你喜欢这个动画的话，欢迎点赞和star我的项目","categories":[{"name":"Android","slug":"Android","permalink":"https://martinbzdqsm.github.io/categories/Android/"}],"tags":[{"name":"matrix","slug":"matrix","permalink":"https://martinbzdqsm.github.io/tags/matrix/"},{"name":"android","slug":"android","permalink":"https://martinbzdqsm.github.io/tags/android/"},{"name":"canvas","slug":"canvas","permalink":"https://martinbzdqsm.github.io/tags/canvas/"}]},{"title":"列表视差效果","slug":"列表视差效果","date":"2017-01-16T07:51:41.000Z","updated":"2017-01-16T11:33:48.912Z","comments":true,"path":"2017/01/16/列表视差效果/","link":"","permalink":"https://martinbzdqsm.github.io/2017/01/16/列表视差效果/","excerpt":"ParallaxScrollImageView 这个控件是做什么的呢？如标题 主要是用于ListView 和RecyclerView中图片的滚动差效果。之前接到这个需求的时候，顺便到网上查了查，发现千篇一律的全是ListView头部的视图滚动差效果，我就想不明白了，他们怎么就取个名字叫做“Parallax ListView”了，加个“head”又不会怎么样，也只好自己动手了。具体的效果如下图： 没看出效果的,可以下载apk体验一下: https://yunpan.cn/c6yFmtfD9cAyL 访问密码 469d 实现流程：1.图片的偏移：图片的偏移，采用的是Canvas的Matrix Translate操作，具体需要计算的参照物如图显示：","text":"ParallaxScrollImageView 这个控件是做什么的呢？如标题 主要是用于ListView 和RecyclerView中图片的滚动差效果。之前接到这个需求的时候，顺便到网上查了查，发现千篇一律的全是ListView头部的视图滚动差效果，我就想不明白了，他们怎么就取个名字叫做“Parallax ListView”了，加个“head”又不会怎么样，也只好自己动手了。具体的效果如下图： 没看出效果的,可以下载apk体验一下: https://yunpan.cn/c6yFmtfD9cAyL 访问密码 469d 实现流程：1.图片的偏移：图片的偏移，采用的是Canvas的Matrix Translate操作，具体需要计算的参照物如图显示： 通过提前设置好组件显示的宽高比来计算出‘图片显示区域’和’真实图片区域’的偏差值，再计算距离中线的距离来计算滑动距离，这样item在滚动时不同组件的高度与中线的距离不同，即产生落差。 12345 if (orientation == Orientation.BOTTOM_TOP) &#123; localMatrix.postTranslate(0.0F, (-(targetDis / 2) - (((targetHeight - screenHeight / 2)) * targetDis) / screenHeight));&#125; else &#123; localMatrix.postTranslate(0.0F,(-(targetDis / 2) + (((targetHeight - screenHeight / 2)) * targetDis) / screenHeight));&#125; 2.视图的滚动/组件的刷新：视图的滚动主要是依靠监听Listview 和RecyclerView的滑动事件做到的，因为组件无法知道自己在列表中什么时候会进行滑动，所以需要监听器进行通知，我在组件中写了一个公开方法1public void doWork() &#123; invalidate();&#125; 而监听器的方法与我们做滑动底部刷新的方法一致，主要是要知道当前在屏幕的的item的数量与坐标，listview 的很简单，这个在网上查一查就知道了。而RecyclerView中由于不同类型的LinearManage获取数量与坐标的方法也有不同，下面来举出：123456789101112131415161718192021222324252627282930@Overridepublic void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); int firstVisibleItem = 0, visibleItemCount = 0; if (GridLayoutManager.class.isInstance(layoutManager)) &#123; //格子 firstVisibleItem = ((GridLayoutManager) layoutManager).findFirstVisibleItemPosition(); visibleItemCount = ((GridLayoutManager) layoutManager).findLastVisibleItemPosition() - firstVisibleItem + 1; &#125; else if (StaggeredGridLayoutManager.class.isInstance(layoutManager)) &#123;//瀑布流 StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager) layoutManager; int[] firstVisibleItems = (staggeredGridLayoutManager).findFirstVisibleItemPositions(new int[staggeredGridLayoutManager.getSpanCount()]); int[] lastVisibleItems = (staggeredGridLayoutManager).findLastVisibleItemPositions(new int[staggeredGridLayoutManager.getSpanCount()]); visibleItemCount = getMaxPosition(lastVisibleItems) - getMinPosition(firstVisibleItems); &#125; else if (LinearLayoutManager.class.isInstance(layoutManager)) &#123; //线性 firstVisibleItem = ((LinearLayoutManager) layoutManager).findFirstVisibleItemPosition(); visibleItemCount = ((LinearLayoutManager) layoutManager).findLastVisibleItemPosition() - firstVisibleItem + 1; &#125; for (int i = 0, count = visibleItemCount; i &lt; count; ++i) &#123; try &#123; ParallaxImageView currentImageView = (ParallaxImageView) recyclerView.getChildAt(i).findViewById(parallaxImageViewId); currentImageView.doWork(); //刷新组件 &#125; catch (NullPointerException e) &#123; &#125; &#125;&#125; 如何使用：1.添加库Step 1. 在你工程的根build.gradle下面添加对仓库的描述:123456allprojects &#123; repositories &#123; ... maven &#123; url \"https://jitpack.io\" &#125; &#125;&#125; Step 2. 添加描述123dependencies &#123; compile 'com.github.MartinBZDQSM:ParallaxScrollImageView:v1.0'&#125; tips: If you already used the appcompat-v7 and recyclerview-v7 try this：1234567compile 'com.android.support:appcompat-v7:' + SUPPORT_VERSION compile 'com.android.support:recyclerview-v7:' + SUPPORT_VERSION compile('com.github.MartinBZDQSM:ParallaxScrollImageView:v1.0') &#123;exclude group: 'com.android.support', module: 'appcompat-v7' exclude group: 'com.android.support', module: 'recyclerview-v7'&#125; 2.如何用?(1)在布局文件中添加ParallaxImageView 并添加相关参数:12345678&lt;martinbzdqsm.com.parallaxscrollimageview_master.ParallaxImageView xmlns:parallax=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/img\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" parallax:img_ratio=\"0.6\" parallax:orientation=\"bottom_top\" parallax:paralax_ratio=\"0.2\" /&gt; parallax:img_ratio ：图片预览时所呈现的高与实际宽度的比值 parallax:paralax_ratio：图片预览时偏移距离与实际宽度的比值 所以 img_ratio+paralax_ratio= height(实际高度)/width(实际宽度) parallax:orientation ： TOP_BOTTOM,BOTTOM_TOP (2)添加滑动监控器: Listview ： parallaxListViewController = new ParallaxListViewController(R.id.img); listView.setOnScrollListener(parallaxListViewController); Recylerview: (GridLayoutManager,StaggeredGridLayoutManager,LinearLayoutManager) GridLayoutManager gridLayoutManager = new GridLayoutManager(this,2); mParallaxRecyclerViewController = new ParallaxRecyclerViewController(gridLayoutManager, R.id.img); mRecyclerView.setLayoutManager(gridLayoutManager); mRecyclerView.addOnScrollListener(mParallaxRecyclerViewController); mRecyclerView.setAdapter(recyclerViewAdapter); Tips: StaggeredGridLayoutManager 瀑布流与其他的用法稍微有点不同,如果有需要可以看下demo如何写的。 项目地址https://github.com/MartinBZDQSM/ParallaxScrollImageView#","categories":[{"name":"Android","slug":"Android","permalink":"https://martinbzdqsm.github.io/categories/Android/"}],"tags":[{"name":"matrix","slug":"matrix","permalink":"https://martinbzdqsm.github.io/tags/matrix/"},{"name":"android","slug":"android","permalink":"https://martinbzdqsm.github.io/tags/android/"},{"name":"canvas","slug":"canvas","permalink":"https://martinbzdqsm.github.io/tags/canvas/"}]},{"title":"图片线条化","slug":"图片线条化","date":"2017-01-16T07:49:08.000Z","updated":"2017-01-16T09:22:16.817Z","comments":true,"path":"2017/01/16/图片线条化/","link":"","permalink":"https://martinbzdqsm.github.io/2017/01/16/图片线条化/","excerpt":"","text":"工具：Photoshop 流程1.准备一张图片2.将原图ps成线条画：将图片在ps中打开，然后ctrl+j 复制一张图层，按住ctrl+shirft+u进行去色。然后选中去掉色的图层： 再按ctrl+j 复制一张图层，按住ctrl+i 进行反相 调整混合模式为颜色减淡，滤镜菜单下选择其他里的最小值滤镜，你自己把控下力度！","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://martinbzdqsm.github.io/categories/杂七杂八/"}],"tags":[{"name":"ps","slug":"ps","permalink":"https://martinbzdqsm.github.io/tags/ps/"},{"name":"adobe","slug":"adobe","permalink":"https://martinbzdqsm.github.io/tags/adobe/"}]},{"title":"图像转Svg","slug":"图像转svg","date":"2017-01-15T15:33:57.000Z","updated":"2017-01-16T09:22:11.146Z","comments":true,"path":"2017/01/15/图像转svg/","link":"","permalink":"https://martinbzdqsm.github.io/2017/01/15/图像转svg/","excerpt":"","text":"工具：Adobe Illustrator 流程之前了解到的勾勒svg路径的工具可能用的比较多的都是GIMP 2,当我问到我司的美工大大的时候，他介绍我Adobe Illustrator 这个流弊哄哄的工具。使用起来超级简单：1.在AI中打开需要处理的图片（下方图只是演示，并不是叫你使用处理过的图，你随意就好了。），然后点击上方的图像临摹按钮：2.调节右方属性中的阈值，调节到你想用的效果 然后点击上方的扩展按钮，并保存成svg，=","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://martinbzdqsm.github.io/categories/杂七杂八/"}],"tags":[{"name":"ps","slug":"ps","permalink":"https://martinbzdqsm.github.io/tags/ps/"},{"name":"adobe","slug":"adobe","permalink":"https://martinbzdqsm.github.io/tags/adobe/"}]}]}