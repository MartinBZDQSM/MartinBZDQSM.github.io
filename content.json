{"meta":{"title":"Martin Blog","subtitle":"记录编程的点滴","description":"记录编程的点滴","author":"Martin","url":"https://martinbzdqsm.github.io"},"pages":[{"title":"about","date":"2017-01-16T06:01:31.000Z","updated":"2017-01-16T06:01:31.885Z","comments":true,"path":"about/index.html","permalink":"https://martinbzdqsm.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-01-16T06:00:27.000Z","updated":"2017-01-16T06:02:22.638Z","comments":false,"path":"categories/index.html","permalink":"https://martinbzdqsm.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-01-16T04:57:20.000Z","updated":"2017-01-16T06:13:12.457Z","comments":true,"path":"tags/index.html","permalink":"https://martinbzdqsm.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Svg渐绘动画","slug":"Svg渐绘动画","date":"2017-01-16T07:53:59.000Z","updated":"2017-01-16T08:12:03.249Z","comments":true,"path":"2017/01/16/Svg渐绘动画/","link":"","permalink":"https://martinbzdqsm.github.io/2017/01/16/Svg渐绘动画/","excerpt":"","text":"先上图： 点子来自于一次情人节的礼物思考，想着能不能不俗套的去送花发红包之类的，再加上妹子也是做技术的，所以就想着搞了一个这个。 这个效果的原理是基于PathView的，可是PathView并不能满足我的需求，于是乎我就开始下手自己修改了。 下面我会一边分析PathView的实现过程，一边描述我是如何修改的(GIF图很多小心流量)。如果你不想看的话项目地址在这https://github.com/MartinBZDQSM/PathDraw ###动画效果如果你了解PathView的动画的话，你就知道它的动画分为两种情况1.getPathAnimator 并行效果2.getSequentialPathAnimator 顺序效果如果你想知道它的实现原理建议查看PathView当中的两个静态内部类AnimatorBuilder和AnimatorSetBuilder。但是当我使用AnimatorSetBuilder 进行顺序绘制的时候我发现效果其实并不好，为什么不好哪里不好呢？看它的源码：1234567891011/** * Sets the duration of the animation. Since the AnimatorSet sets the duration for each * Animator, we have to divide it by the number of paths. * * @param duration - The duration of the animation. * @return AnimatorSetBuilder. */ public AnimatorSetBuilder duration(final int duration) &#123; this.duration = duration / paths.size(); return this; &#125; 看完以上代码你就会知道PathView的作者计算出来的动画时间是你设置的平均时间，也就是说不管我这条path的路径到底有多长，所有path的执行时间都是一样的。那我画一个点和画一条直线的时间都是一样的是不是有点扯？所以我在这里增加了平均时间的计算，根据计算path的长度在总长度中的占比，然后单个设置时间,进行顺序轮播,我也试过使用AnimatorSet单独设置Animator的时间,但是好像并没有效果,所以我用比较蠢点方法进行了实现，大致修改的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * Default constructor. * * @param pathView The view that must be animated. */public AnimatorSetBuilder(final PathDrawingView pathView) &#123; paths = pathView.mPaths; if (pathViewAnimatorListener == null) &#123; pathViewAnimatorListener = new PathViewAnimatorListener(); &#125; for (PathLayer.SvgPath path : paths) &#123; path.setAnimationStepListener(pathView); ObjectAnimator animation = ObjectAnimator.ofFloat(path, &quot;length&quot;, 0.0f, path.getLength()); totalLenth = totalLenth + path.getLength(); animators.add(animation); &#125; for (int i = 0; i &lt; paths.size(); i++) &#123; long animationDuration = (long) (paths.get(i).getLength() * duration / totalLenth); Animator animator = animators.get(i); animator.setStartDelay(delay); animator.setDuration(animationDuration); animator.addListener(pathViewAnimatorListener); &#125;&#125;/** * Starts the animation. */public void start() &#123; resetAllPaths(); for (Animator animator : animators) &#123; animator.cancel(); &#125; index = 0; startAnimatorByIndex();&#125;public void startAnimatorByIndex() &#123; if (index &gt;= paths.size()) &#123; return; &#125; Animator animator = animators.get(index); animator.start();&#125;/** * Sets the length of all the paths to 0. */private void resetAllPaths() &#123; for (PathLayer.SvgPath path : paths) &#123; path.setLength(0); &#125;&#125;/** * Called when the animation start. */public interface ListenerStart &#123; /** * Called when the path animation start. */ void onAnimationStart();&#125;/** * Called when the animation end. */public interface ListenerEnd &#123; /** * Called when the path animation end. */ void onAnimationEnd();&#125;/** * Animation listener to be able to provide callbacks for the caller. */private class PathViewAnimatorListener implements Animator.AnimatorListener &#123; @Override public void onAnimationStart(Animator animation) &#123; if (index &lt; paths.size() - 1) &#123; paths.get(index).isMeasure = true; PathDrawingView.isDrawing = true; if (index == 0 &amp;&amp; listenerStart != null) listenerStart.onAnimationStart(); &#125; &#125; @Override public void onAnimationEnd(Animator animation) &#123; if (index &gt;= paths.size() - 1) &#123; PathDrawingView.isDrawing = false; if (animationEnd != null) animationEnd.onAnimationEnd(); &#125; else &#123; if (index &lt; paths.size() - 1) &#123; paths.get(index).isMeasure = false; index++; startAnimatorByIndex(); &#125; &#125; &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125;&#125; ###画笔动态跟踪PathView中线条渐变是通过截取path当中的片段做成的，看码:1234567891011121314/** * Sets the length of the path. * * @param length The length to be set. */ public void setLength(float length) &#123; path.reset(); measure.getSegment(0.0f, length, path, true); path.rLineTo(0.0f, 0.0f); if (animationStepListener != null) &#123; animationStepListener.onAnimationStep(); &#125; &#125; 既然动画的原理是通过改变截取的长度做到的，那么只要能获取到截取长度最后的那个点是不是就可以充当轨迹了？所以这里只需要添加一个锚点，每当截取长度变化的时候，锚点也跟着改变,看代码：123456789public void setLength(float length) &#123; path.reset(); measure.getSegment(0.0f, length, path, true); measure.getPosTan(length, point, null);//跟踪锚点 path.rLineTo(0.0f, 0.0f); if (animationStepListener != null) &#123; animationStepListener.onAnimationStep(); &#125; &#125; 笔尖移动的原理，需要提前计算好笔尖在画笔图片中的坐标，然后对照着锚点进行移动就行了。Tips:这里我的画笔图片还没有针对画布宽高进行缩放，所以在不同分辨率的情况下画笔显示的大小可能是不一致的。 ###我认知的FillPathView中对于Path的Paint选的是Stroke属性,而如果需要进行填充,则需要所有的线条绘制完成之后才能进行填充或者默认填充。看PathView的源码:1234567891011121314151617181920212223242526272829303132@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if(mTempBitmap==null || (mTempBitmap.getWidth()!=canvas.getWidth()||mTempBitmap.getHeight()!=canvas.getHeight()) ) &#123; mTempBitmap = Bitmap.createBitmap(canvas.getWidth(), canvas.getHeight(), Bitmap.Config.ARGB_8888); mTempCanvas = new Canvas(mTempBitmap); &#125; mTempBitmap.eraseColor(0); synchronized (mSvgLock) &#123; mTempCanvas.save(); mTempCanvas.translate(getPaddingLeft(), getPaddingTop()); fill(mTempCanvas);//直接进行填充 final int count = paths.size(); for (int i = 0; i &lt; count; i++) &#123; final SvgUtils.SvgPath svgPath = paths.get(i); final Path path = svgPath.path; final Paint paint1 = naturalColors ? svgPath.paint : paint; mTempCanvas.drawPath(path, paint1); &#125; fillAfter(mTempCanvas);//线条绘制完成之后 在进行填充 mTempCanvas.restore(); applySolidColor(mTempBitmap); canvas.drawBitmap(mTempBitmap,0,0,null); &#125;&#125; 其实这里选Stroke属性还是Fill属性都是看svg的情况而定,针对于我自己做的这个svg图，我对比了三种属性的不同效果,看图:看了上图我们可以发现,如果我们使用的svg不是由单线条组成的,会感觉特别怪异,而Fill和Fill And Stroke则显示的较为舒服。更贴近svg在浏览器显示出来的效果。那么问题来了！ 如果我们使用Fill 属性或者Fill And Stroke属性，在线条绘制过程中会把所截取的Path的起点和重点连接起来形成一个闭合区域。我把这种情况叫做“绘制过度”（瞎取的），看图： 为什么会导致这种情况看我画的这张图你就会明白了； 在path往回绘制的时候，paint并不知道接下来会如何填充，所以就直接连接了迂回点和终点。 那么如何消除Fill属性带来的影响呢？刚开始我想了大致两个思路并进行了尝试： ####1.多保留一份Paths，在绘制的时候Clip原path路径。 ####2.多保留一份Paths，使用PorterDuffXfermode，当绘制的时候显示被绘制的path遮挡的部分。 我先实现了思路1，看我如何实现的：1234567891011121314151617181920212223@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int sc = canvas.save(Canvas.ALL_SAVE_FLAG); synchronized (mSvgLock) &#123; int count = mPaths.size(); for (int i = 0; i &lt; count; i++) &#123; int pc = canvas.save(Canvas.ALL_SAVE_FLAG); //需要备用一个完整的path路径，来修复pathPaint的Fill造成绘制过度 Path path = pathLayer.mDrawer.get(i);//这个pathLayer 指的就是Pathview中的SvgUtils canvas.clipPath(path); PathLayer.SvgPath svgPath = mPaths.get(i); canvas.drawPath(svgPath.path, pathPaint); canvas.restoreToCount(pc); &#125; &#125; canvas.restoreToCount(sc); for (PathLayer.SvgPath svgPath : mPaths) &#123; if (isDrawing &amp;&amp; svgPath.isMeasure) &#123;//过滤初始为0的点 canvas.drawBitmap(paintLayer, svgPath.point[0] - nibPointf.x, svgPath.point[1] - nibPointf.y, null); &#125; &#125; &#125; 看效果： 仔细看效果发现其实还是有问题存在的，再线条迂回的地方会把遗漏； 为什么会导致这种情况,其实还是前面讲到过的绘制过度。于是我尝试了下实现下思路2：12345678910111213141516171819202122232425private PorterDuffXfermode xfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT);@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int sc = canvas.save(Canvas.ALL_SAVE_FLAG); synchronized (mSvgLock) &#123; int count = mPaths.size(); for (int i = 0; i &lt; count; i++) &#123; int pc = canvas.save(Canvas.ALL_SAVE_FLAG); PathLayer.SvgPath svgPath = mPaths.get(i); if (isFill) &#123; //需要备用一个完整的path路径，来修复pathPaint的Fill造成绘制过度 Path path = pathLayer.mDrawer.get(i); canvas.clipPath(path); if (isDrawing &amp;&amp; svgPath.isMeasure) &#123; canvas.drawPath(path, drawerPaint); &#125; &#125; canvas.drawPath(svgPath.path, pathPaint); canvas.restoreToCount(pc); &#125; &#125; canvas.restoreToCount(sc);&#125; 效果如下： 关于为什么要使用PorterDuff.Mode.SRC_OUT，其实我是试出来的0.0，本以为这样就完美了，但是我发现当仔细看发现颜色他么怎么变成黑色了（我用的是灰色）！！！然后我尝试了使用一张Bitmap的Canvas来代替view的Canvas再渲染像素点的颜色的时候，发现效果又乱了！！！！真是奇怪，为了研究原因我将 canvas.clipPath(path);去掉，发现了新大陆,看图： 原来PorterDuff.Mode.SRC_OUT将非覆盖面生成了矩形块，那么新思路就有了：3.直接截取path的矩形块：1234567if (isFill) &#123; //需要备用一个完整的path路径，来修复pathPaint的Fill造成绘制过度 Path path = pathLayer.mDrawer.get(i); canvas.clipPath(path); svgPath.path.computeBounds(drawRect, true); canvas.drawRect(drawRect, drawerPaint); &#125; 最终效果图就和文章最开始的显示效果一致了,哈哈 几经波折终于出现好效果啦!。 ####如何制作svg关于如何制作成这样的svg ，你可以考虑看我的文章：《如何将图片生成svg》，使用的是Adobe Illustrator而不是GMIP2 ##最后，如果你喜欢或者有何意见，不妨Star或者给我提Issuses哦！项目地址","categories":[{"name":"Android","slug":"Android","permalink":"https://martinbzdqsm.github.io/categories/Android/"}],"tags":[{"name":"matrix","slug":"matrix","permalink":"https://martinbzdqsm.github.io/tags/matrix/"},{"name":"android","slug":"android","permalink":"https://martinbzdqsm.github.io/tags/android/"},{"name":"canvas","slug":"canvas","permalink":"https://martinbzdqsm.github.io/tags/canvas/"},{"name":"svg","slug":"svg","permalink":"https://martinbzdqsm.github.io/tags/svg/"}]},{"title":"利用Matrix让蝴蝶动起来","slug":"利用Matrix让蝴蝶动起来","date":"2017-01-16T07:53:35.000Z","updated":"2017-01-16T08:36:09.015Z","comments":true,"path":"2017/01/16/利用Matrix让蝴蝶动起来/","link":"","permalink":"https://martinbzdqsm.github.io/2017/01/16/利用Matrix让蝴蝶动起来/","excerpt":"","text":"有幸在鸿洋的一篇Android FoldingLayout 折叠布局 原理及实现（一）中，学习到了Matrix的setPolyToPoly操作，于是着想到了如何实现这样一个的动画效果。先上图：项目地址，gif有点掉帧，完整效果直接把项目clone下来试试就行了。 整体思路由三个部分组成：1.蝴蝶的绘制。2.折叠动画。3.细节抖动。 下面大概描述一下实现过程： ###蝴蝶的绘制蝴蝶的绘制使用的是svg+图片融合PorterDuffXfermode，对 这并不是一张图片，也就是说蝴蝶上的花纹是可以随意变化的。在布局中添加花纹代码如下：123456&lt;com.martin.butterfly.master.ButterFlyLoadView android:id=&quot;@+id/mbutterfly_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:figure=&quot;@drawable/figure1&quot; /&gt; 关于svg的转化我并没有使用常见的解析方式；而是使用的是SVG2Drawable,去除了关于svg的解析过程，直接使用生成后的path代码。在组件初始化的时候使用PorterDuffXfermode生成相关花纹的蝴蝶图片。 ###折叠动画折叠的原理还是跟文章头部所说到的Android FoldingLayout 折叠布局 原理及实现（一）与其原理一致，主要判断好两支翅膀的矩形块与ToPoly的变化，这里不再复述了，如果需要了解该api的话可以去看看鸿洋的博客，我将这些变化都封装在ButterFlyDrawable中方便更改视图效果，并不仅仅使用在dialog之中。 ###细节抖动如果仅仅是蝴蝶扇翅膀，我觉得不怎么生动，为此我还增加细节抖动，使蝴蝶扇动的更逼真点。 如果你喜欢这个动画的话，欢迎点赞和star我的项目","categories":[{"name":"Android","slug":"Android","permalink":"https://martinbzdqsm.github.io/categories/Android/"}],"tags":[{"name":"matrix","slug":"matrix","permalink":"https://martinbzdqsm.github.io/tags/matrix/"},{"name":"android","slug":"android","permalink":"https://martinbzdqsm.github.io/tags/android/"},{"name":"canvas","slug":"canvas","permalink":"https://martinbzdqsm.github.io/tags/canvas/"}]},{"title":"列表视差效果","slug":"列表视差效果","date":"2017-01-16T07:51:41.000Z","updated":"2017-01-16T08:13:59.874Z","comments":true,"path":"2017/01/16/列表视差效果/","link":"","permalink":"https://martinbzdqsm.github.io/2017/01/16/列表视差效果/","excerpt":"","text":"#####ParallaxScrollImageView 这个控件是做什么的呢？如标题 主要是用于ListView 和RecyclerView中图片的滚动差效果。之前接到这个需求的时候，顺便到网上查了查，发现千篇一律的全是ListView头部的视图滚动差效果，我就想不明白了，他们怎么就取个名字叫做“Parallax ListView”了，加个“head”又不会怎么样，也只好自己动手了。具体的效果如下图：##### 没看出效果的,可以下载apk体验一下: https://yunpan.cn/c6yFmtfD9cAyL 访问密码 469d ##实现流程：## ###1.图片的偏移：图片的偏移，采用的是Canvas的Matrix Translate操作，具体需要计算的参照物如图显示： 通过提前设置好组件显示的宽高比来计算出‘图片显示区域’和’真实图片区域’的偏差值，再计算距离中线的距离来计算滑动距离，这样item在滚动时不同组件的高度与中线的距离不同，即产生落差。 12345 if (orientation == Orientation.BOTTOM_TOP) &#123; localMatrix.postTranslate(0.0F, (-(targetDis / 2) - (((targetHeight - screenHeight / 2)) * targetDis) / screenHeight));&#125; else &#123; localMatrix.postTranslate(0.0F,(-(targetDis / 2) + (((targetHeight - screenHeight / 2)) * targetDis) / screenHeight));&#125; ###2.视图的滚动/组件的刷新：视图的滚动主要是依靠监听Listview 和RecyclerView的滑动事件做到的，因为组件无法知道自己在列表中什么时候会进行滑动，所以需要监听器进行通知，我在组件中写了一个公开方法1public void doWork() &#123; invalidate();&#125; 而监听器的方法与我们做滑动底部刷新的方法一致，主要是要知道当前在屏幕的的item的数量与坐标，listview 的很简单，这个在网上查一查就知道了。而RecyclerView中由于不同类型的LinearManage获取数量与坐标的方法也有不同，下面来举出：123456789101112131415161718192021222324252627282930@Overridepublic void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); int firstVisibleItem = 0, visibleItemCount = 0; if (GridLayoutManager.class.isInstance(layoutManager)) &#123; //格子 firstVisibleItem = ((GridLayoutManager) layoutManager).findFirstVisibleItemPosition(); visibleItemCount = ((GridLayoutManager) layoutManager).findLastVisibleItemPosition() - firstVisibleItem + 1; &#125; else if (StaggeredGridLayoutManager.class.isInstance(layoutManager)) &#123;//瀑布流 StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager) layoutManager; int[] firstVisibleItems = (staggeredGridLayoutManager).findFirstVisibleItemPositions(new int[staggeredGridLayoutManager.getSpanCount()]); int[] lastVisibleItems = (staggeredGridLayoutManager).findLastVisibleItemPositions(new int[staggeredGridLayoutManager.getSpanCount()]); visibleItemCount = getMaxPosition(lastVisibleItems) - getMinPosition(firstVisibleItems); &#125; else if (LinearLayoutManager.class.isInstance(layoutManager)) &#123; //线性 firstVisibleItem = ((LinearLayoutManager) layoutManager).findFirstVisibleItemPosition(); visibleItemCount = ((LinearLayoutManager) layoutManager).findLastVisibleItemPosition() - firstVisibleItem + 1; &#125; for (int i = 0, count = visibleItemCount; i &lt; count; ++i) &#123; try &#123; ParallaxImageView currentImageView = (ParallaxImageView) recyclerView.getChildAt(i).findViewById(parallaxImageViewId); currentImageView.doWork(); //刷新组件 &#125; catch (NullPointerException e) &#123; &#125; &#125;&#125; ##如何使用：## 1.添加库Step 1. 在你工程的根build.gradle下面添加对仓库的描述: allprojects { repositories { ... maven { url &quot;https://jitpack.io&quot; } } } Step 2. 添加描述 dependencies { compile &apos;com.github.MartinBZDQSM:ParallaxScrollImageView:v1.0&apos; } tips: If you already used the appcompat-v7 and recyclerview-v7 try this： compile &apos;com.android.support:appcompat-v7:&apos; + SUPPORT_VERSION compile &apos;com.android.support:recyclerview-v7:&apos; + SUPPORT_VERSION compile(&apos;com.github.MartinBZDQSM:ParallaxScrollImageView:v1.0&apos;) { exclude group: &apos;com.android.support&apos;, module: &apos;appcompat-v7&apos; exclude group: &apos;com.android.support&apos;, module: &apos;recyclerview-v7&apos; } 2.如何用?(1)在布局文件中添加ParallaxImageView 并添加相关参数:12345678&lt;martinbzdqsm.com.parallaxscrollimageview_master.ParallaxImageView xmlns:parallax=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/img\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" parallax:img_ratio=\"0.6\" parallax:orientation=\"bottom_top\" parallax:paralax_ratio=\"0.2\" /&gt; parallax:img_ratio ：图片预览时所呈现的高与实际宽度的比值 parallax:paralax_ratio：图片预览时偏移距离与实际宽度的比值 所以 img_ratio+paralax_ratio= height(实际高度)/width(实际宽度) parallax:orientation ： TOP_BOTTOM,BOTTOM_TOP (2)添加滑动监控器: Listview ： parallaxListViewController = new ParallaxListViewController(R.id.img); listView.setOnScrollListener(parallaxListViewController); Recylerview: (GridLayoutManager,StaggeredGridLayoutManager,LinearLayoutManager) GridLayoutManager gridLayoutManager = new GridLayoutManager(this, 2); mParallaxRecyclerViewController = new ParallaxRecyclerViewController(gridLayoutManager, R.id.img); mRecyclerView.setLayoutManager(gridLayoutManager); mRecyclerView.addOnScrollListener(mParallaxRecyclerViewController); mRecyclerView.setAdapter(recyclerViewAdapter); Tips: StaggeredGridLayoutManager 瀑布流与其他的用法稍微有点不同,如果有需要可以看下demo如何写的。 #项目地址https://github.com/MartinBZDQSM/ParallaxScrollImageView#","categories":[{"name":"Android","slug":"Android","permalink":"https://martinbzdqsm.github.io/categories/Android/"}],"tags":[{"name":"matrix","slug":"matrix","permalink":"https://martinbzdqsm.github.io/tags/matrix/"},{"name":"android","slug":"android","permalink":"https://martinbzdqsm.github.io/tags/android/"},{"name":"canvas","slug":"canvas","permalink":"https://martinbzdqsm.github.io/tags/canvas/"}]},{"title":"图片线条化","slug":"图片线条化","date":"2017-01-16T07:49:08.000Z","updated":"2017-01-16T08:08:15.713Z","comments":true,"path":"2017/01/16/图片线条化/","link":"","permalink":"https://martinbzdqsm.github.io/2017/01/16/图片线条化/","excerpt":"","text":"###工具：Photoshop ###流程1.准备一张图片2.将原图ps成线条画：将图片在ps中打开，然后ctrl+j 复制一张图层，按住ctrl+shirft+u进行去色。然后选中去掉色的图层： 再按ctrl+j 复制一张图层，按住ctrl+i 进行反相 调整混合模式为颜色减淡，滤镜菜单下选择其他里的最小值滤镜，你自己把控下力度！","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://martinbzdqsm.github.io/categories/杂七杂八/"}],"tags":[{"name":"ps","slug":"ps","permalink":"https://martinbzdqsm.github.io/tags/ps/"},{"name":"adobe","slug":"adobe","permalink":"https://martinbzdqsm.github.io/tags/adobe/"}]},{"title":"图像转Svg","slug":"图像转svg","date":"2017-01-15T15:33:57.000Z","updated":"2017-01-16T08:09:21.169Z","comments":true,"path":"2017/01/15/图像转svg/","link":"","permalink":"https://martinbzdqsm.github.io/2017/01/15/图像转svg/","excerpt":"","text":"###工具：Adobe Illustrator ###流程之前了解到的勾勒svg路径的工具可能用的比较多的都是GIMP 2,当我问到我司的美工大大的时候，他介绍我Adobe Illustrator 这个流弊哄哄的工具。使用起来超级简单：1.在AI中打开需要处理的图片（下方图只是演示，并不是叫你使用处理过的图，你随意就好了。），然后点击上方的图像临摹按钮：2.调节右方属性中的阈值，调节到你想用的效果 然后点击上方的扩展按钮，并保存成svg，=","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://martinbzdqsm.github.io/categories/杂七杂八/"}],"tags":[{"name":"ps","slug":"ps","permalink":"https://martinbzdqsm.github.io/tags/ps/"},{"name":"adobe","slug":"adobe","permalink":"https://martinbzdqsm.github.io/tags/adobe/"}]}]}