<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>svg渐绘动画 | Martin Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="matrixandroidcanvassvg" />
  
  
  
  
  <meta name="description" content="先上图：
点子来自于一次情人节的礼物思考，想着能不能不俗套的去送花发红包之类的，再加上妹子也是做技术的，所以就想着搞了一个这个。
这个效果的原理是基于PathView的，可是PathView并不能满足我的需求，于是乎我就开始下手自己修改了。
下面我会一边分析PathView的实现过程，一边描述我是如何修改的(GIF图很多小心流量)。如果你不想看的话项目地址在这https://github.com/">
<meta property="og:type" content="article">
<meta property="og:title" content="Svg渐绘动画">
<meta property="og:url" content="https://martinbzdqsm.github.io/2017/01/16/Svg渐绘动画/index.html">
<meta property="og:site_name" content="Martin Blog">
<meta property="og:description" content="先上图：
点子来自于一次情人节的礼物思考，想着能不能不俗套的去送花发红包之类的，再加上妹子也是做技术的，所以就想着搞了一个这个。
这个效果的原理是基于PathView的，可是PathView并不能满足我的需求，于是乎我就开始下手自己修改了。
下面我会一边分析PathView的实现过程，一边描述我是如何修改的(GIF图很多小心流量)。如果你不想看的话项目地址在这https://github.com/">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2510337-239ae20eee991fb2.gif?imageMogr2/auto-orient/strip">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2510337-bef3ad4f675780c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2510337-259388f9a97b0e48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2510337-68f15dd9652d87a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2510337-ef4de36d4de4292f.gif?imageMogr2/auto-orient/strip">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2510337-bf3af403df3f505b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2510337-d1414a0cd9abb9cd.gif?imageMogr2/auto-orient/strip">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2510337-0e6025018e95b1d1.gif?imageMogr2/auto-orient/strip">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2510337-441047ef432479b0.gif?imageMogr2/auto-orient/strip">
<meta property="og:updated_time" content="2017-01-16T09:01:40.068Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Svg渐绘动画">
<meta name="twitter:description" content="先上图：
点子来自于一次情人节的礼物思考，想着能不能不俗套的去送花发红包之类的，再加上妹子也是做技术的，所以就想着搞了一个这个。
这个效果的原理是基于PathView的，可是PathView并不能满足我的需求，于是乎我就开始下手自己修改了。
下面我会一边分析PathView的实现过程，一边描述我是如何修改的(GIF图很多小心流量)。如果你不想看的话项目地址在这https://github.com/">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/2510337-239ae20eee991fb2.gif?imageMogr2/auto-orient/strip">
  
    <link rel="alternate" href="/atom.xml" title="Martin Blog" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="Martin Blog" rel="home"> Martin Blog </a>
            
          </h1>

          
            <div class="site-description">记录编程的点滴</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>




  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Svg渐绘动画" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Svg渐绘动画
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/2017/01/16/Svg渐绘动画/" class="article-date">
	  <time datetime="2017-01-16T07:53:59.000Z" itemprop="datePublished">一月 16, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>先上图：<br><img src="http://upload-images.jianshu.io/upload_images/2510337-239ae20eee991fb2.gif?imageMogr2/auto-orient/strip" alt="nancy.gif"></p>
<p><strong><br>点子来自于一次情人节的礼物思考，想着能不能不俗套的去送花发红包之类的，再加上妹子也是做技术的，所以就想着搞了一个这个。
</strong><br><strong><br>这个效果的原理是基于<a href="https://github.com/geftimov/android-pathview" target="_blank" rel="external">PathView</a>的，可是<a href="https://github.com/geftimov/android-pathview" target="_blank" rel="external">PathView</a>并不能满足我的需求，于是乎我就开始下手自己修改了。
</strong><br><strong><br>下面我会一边分析<a href="https://github.com/geftimov/android-pathview" target="_blank" rel="external">PathView</a>的实现过程，一边描述我是如何修改的(GIF图很多小心流量)。如果你不想看的话项目地址在这<br><a href="https://github.com/MartinBZDQSM/PathDraw" target="_blank" rel="external">https://github.com/MartinBZDQSM/PathDraw</a>
</strong></p>
<h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><p>如果你了解<a href="https://github.com/geftimov/android-pathview" target="_blank" rel="external">PathView</a>的动画的话，你就知道它的动画分为两种情况<br>1.getPathAnimator 并行效果<br>2.getSequentialPathAnimator 顺序效果<br>如果你想知道它的实现原理建议查看<a href="https://github.com/geftimov/android-pathview" target="_blank" rel="external">PathView</a>当中的两个静态内部类AnimatorBuilder和AnimatorSetBuilder。<br>但是当我使用AnimatorSetBuilder 进行顺序绘制的时候我发现效果其实并不好，为什么不好哪里不好呢？看它的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Sets the duration of the animation. Since the AnimatorSet sets the duration for each</div><div class="line">    * Animator, we have to divide it by the number of paths.</div><div class="line">    *</div><div class="line">    * @param duration - The duration of the animation.</div><div class="line">    * @return AnimatorSetBuilder.</div><div class="line">    */</div><div class="line">   public AnimatorSetBuilder duration(final int duration) &#123;</div><div class="line">       this.duration = duration / paths.size();</div><div class="line">       return this;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>看完以上代码你就会知道<a href="https://github.com/geftimov/android-pathview" target="_blank" rel="external">PathView</a>的作者计算出来的动画时间是你设置的平均时间，也就是说不管我这条path的路径到底有多长，所有path的执行时间都是一样的。那我画一个点和画一条直线的时间都是一样的是不是有点扯？所以我在这里增加了平均时间的计算，根据计算path的长度在总长度中的占比，然后单个设置时间,进行顺序轮播,我也试过使用AnimatorSet单独设置Animator的时间,但是好像并没有效果,所以我用比较蠢点方法进行了实现，大致修改的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Default constructor.</div><div class="line"> *</div><div class="line"> * @param pathView The view that must be animated.</div><div class="line"> */</div><div class="line">public AnimatorSetBuilder(final PathDrawingView pathView) &#123;</div><div class="line">    paths = pathView.mPaths;</div><div class="line">    if (pathViewAnimatorListener == null) &#123;</div><div class="line">        pathViewAnimatorListener = new PathViewAnimatorListener();</div><div class="line">    &#125;</div><div class="line">    for (PathLayer.SvgPath path : paths) &#123;</div><div class="line">        path.setAnimationStepListener(pathView);</div><div class="line">        ObjectAnimator animation = ObjectAnimator.ofFloat(path, &quot;length&quot;, 0.0f, path.getLength());</div><div class="line">        totalLenth = totalLenth + path.getLength();</div><div class="line">        animators.add(animation);</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; paths.size(); i++) &#123;</div><div class="line">        long animationDuration = (long) (paths.get(i).getLength() * duration / totalLenth);</div><div class="line">        Animator animator = animators.get(i);</div><div class="line">        animator.setStartDelay(delay);</div><div class="line">        animator.setDuration(animationDuration);</div><div class="line">        animator.addListener(pathViewAnimatorListener);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * Starts the animation.</div><div class="line"> */</div><div class="line">public void start() &#123;</div><div class="line">    resetAllPaths();</div><div class="line">    for (Animator animator : animators) &#123;</div><div class="line">        animator.cancel();</div><div class="line">    &#125;</div><div class="line">    index = 0;</div><div class="line">    startAnimatorByIndex();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void startAnimatorByIndex() &#123;</div><div class="line">    if (index &gt;= paths.size()) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    Animator animator = animators.get(index);</div><div class="line">    animator.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Sets the length of all the paths to 0.</div><div class="line"> */</div><div class="line">private void resetAllPaths() &#123;</div><div class="line">    for (PathLayer.SvgPath path : paths) &#123;</div><div class="line">        path.setLength(0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Called when the animation start.</div><div class="line"> */</div><div class="line">public interface ListenerStart &#123;</div><div class="line">    /**</div><div class="line">     * Called when the path animation start.</div><div class="line">     */</div><div class="line">    void onAnimationStart();</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Called when the animation end.</div><div class="line"> */</div><div class="line">public interface ListenerEnd &#123;</div><div class="line">    /**</div><div class="line">     * Called when the path animation end.</div><div class="line">     */</div><div class="line">    void onAnimationEnd();</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Animation listener to be able to provide callbacks for the caller.</div><div class="line"> */</div><div class="line">private class PathViewAnimatorListener implements Animator.AnimatorListener &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onAnimationStart(Animator animation) &#123;</div><div class="line">        if (index &lt; paths.size() - 1) &#123;</div><div class="line">            paths.get(index).isMeasure = true;</div><div class="line">            PathDrawingView.isDrawing = true;</div><div class="line">            if (index == 0 &amp;&amp; listenerStart != null)</div><div class="line">                listenerStart.onAnimationStart();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onAnimationEnd(Animator animation) &#123;</div><div class="line">        if (index &gt;= paths.size() - 1) &#123;</div><div class="line">            PathDrawingView.isDrawing = false;</div><div class="line">            if (animationEnd != null)</div><div class="line">                animationEnd.onAnimationEnd();</div><div class="line">        &#125; else &#123;</div><div class="line">            if (index &lt; paths.size() - 1) &#123;</div><div class="line">                paths.get(index).isMeasure = false;</div><div class="line">                index++;</div><div class="line">                startAnimatorByIndex();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onAnimationCancel(Animator animation) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onAnimationRepeat(Animator animation) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###画笔动态跟踪<br><a href="https://github.com/geftimov/android-pathview" target="_blank" rel="external">PathView</a>中线条渐变是通过截取path当中的片段做成的，看码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Sets the length of the path.</div><div class="line">    *</div><div class="line">    * @param length The length to be set.</div><div class="line">    */</div><div class="line">   public void setLength(float length) &#123;</div><div class="line">       path.reset();</div><div class="line">       measure.getSegment(0.0f, length, path, true);</div><div class="line">       path.rLineTo(0.0f, 0.0f);</div><div class="line"></div><div class="line">       if (animationStepListener != null) &#123;</div><div class="line">           animationStepListener.onAnimationStep();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>既然动画的原理是通过改变截取的长度做到的，那么只要能获取到截取长度最后的那个点是不是就可以充当轨迹了？<br>所以这里只需要添加一个锚点，每当截取长度变化的时候，锚点也跟着改变,看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void setLength(float length) &#123;</div><div class="line">        path.reset();</div><div class="line">        measure.getSegment(0.0f, length, path, true);</div><div class="line">        measure.getPosTan(length, point, null);//跟踪锚点</div><div class="line">        path.rLineTo(0.0f, 0.0f);</div><div class="line">        if (animationStepListener != null) &#123;</div><div class="line">            animationStepListener.onAnimationStep();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>笔尖移动的原理，需要提前计算好笔尖在画笔图片中的坐标，然后对照着锚点进行移动就行了。<br>Tips:这里我的画笔图片还没有针对画布宽高进行缩放，所以在不同分辨率的情况下画笔显示的大小可能是不一致的。</p>
<p>###我认知的Fill<br><a href="https://github.com/geftimov/android-pathview" target="_blank" rel="external">PathView</a>中对于Path的Paint选的是Stroke属性,而如果需要进行填充,则需要所有的线条绘制完成之后才能进行填充或者默认填充。看<a href="https://github.com/geftimov/android-pathview" target="_blank" rel="external">PathView</a>的源码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line"></div><div class="line">    if(mTempBitmap==null || (mTempBitmap.getWidth()!=canvas.getWidth()||mTempBitmap.getHeight()!=canvas.getHeight()) )</div><div class="line">    &#123;</div><div class="line">        mTempBitmap = Bitmap.createBitmap(canvas.getWidth(), canvas.getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">        mTempCanvas = new Canvas(mTempBitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mTempBitmap.eraseColor(0);</div><div class="line">    synchronized (mSvgLock) &#123;</div><div class="line">        mTempCanvas.save();</div><div class="line">        mTempCanvas.translate(getPaddingLeft(), getPaddingTop());</div><div class="line">        fill(mTempCanvas);//直接进行填充</div><div class="line">        final int count = paths.size();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            final SvgUtils.SvgPath svgPath = paths.get(i);</div><div class="line">            final Path path = svgPath.path;</div><div class="line">            final Paint paint1 = naturalColors ? svgPath.paint : paint;</div><div class="line">            mTempCanvas.drawPath(path, paint1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        fillAfter(mTempCanvas);//线条绘制完成之后 在进行填充</div><div class="line"></div><div class="line">        mTempCanvas.restore();</div><div class="line"></div><div class="line">        applySolidColor(mTempBitmap);</div><div class="line"></div><div class="line">        canvas.drawBitmap(mTempBitmap,0,0,null);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实这里选Stroke属性还是Fill属性都是看svg的情况而定,针对于我自己做的这个svg图，我对比了三种属性的不同效果,看图:<br><img src="http://upload-images.jianshu.io/upload_images/2510337-bef3ad4f675780c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="STROKE.png"><br>看了上图我们可以发现,如果我们使用的svg不是由<strong>单线条</strong>组成的,会感觉特别怪异,而Fill和Fill And Stroke则显示的较为舒服。更贴近svg在浏览器显示出来的效果。<br>那么问题来了！ 如果我们使用Fill 属性或者Fill And Stroke属性，在线条绘制过程中会把所截取的Path的起点和重点连接起来形成一个闭合区域。我把这种情况叫做“绘制过度”（瞎取的），看图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2510337-259388f9a97b0e48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>为什么会导致这种情况看我画的这张图你就会明白了；</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2510337-68f15dd9652d87a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>在path往回绘制的时候，paint并不知道接下来会如何填充，所以就直接连接了迂回点和终点。</p>
<p>那么如何消除Fill属性带来的影响呢？刚开始我想了大致两个思路并进行了尝试：</p>
<p>####1.多保留一份Paths，在绘制的时候Clip原path路径。</p>
<p>####2.多保留一份Paths，使用PorterDuffXfermode，当绘制的时候显示被绘制的path遮挡的部分。</p>
<p>我先实现了思路1，看我如何实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   protected void onDraw(Canvas canvas) &#123;</div><div class="line">       super.onDraw(canvas);</div><div class="line">       int sc = canvas.save(Canvas.ALL_SAVE_FLAG);</div><div class="line">       synchronized (mSvgLock) &#123;</div><div class="line">           int count = mPaths.size();</div><div class="line">           for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">               int pc = canvas.save(Canvas.ALL_SAVE_FLAG);</div><div class="line">               //需要备用一个完整的path路径，来修复pathPaint的Fill造成绘制过度</div><div class="line">               Path path = pathLayer.mDrawer.get(i);//这个pathLayer 指的就是Pathview中的SvgUtils</div><div class="line">               canvas.clipPath(path);</div><div class="line">               PathLayer.SvgPath svgPath = mPaths.get(i);</div><div class="line">               canvas.drawPath(svgPath.path, pathPaint);</div><div class="line">               canvas.restoreToCount(pc);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       canvas.restoreToCount(sc);</div><div class="line">       for (PathLayer.SvgPath svgPath : mPaths) &#123;</div><div class="line">           if (isDrawing &amp;&amp; svgPath.isMeasure) &#123;//过滤初始为0的点</div><div class="line">               canvas.drawBitmap(paintLayer, svgPath.point[0] - nibPointf.x, svgPath.point[1] - nibPointf.y, null);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>看效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2510337-ef4de36d4de4292f.gif?imageMogr2/auto-orient/strip" alt="nancy.gif"><br>仔细看效果发现其实还是有问题存在的，再线条迂回的地方会把遗漏；</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2510337-bf3af403df3f505b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>为什么会导致这种情况,其实还是前面讲到过的绘制过度。<br>于是我尝试了下实现下思路2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private PorterDuffXfermode xfermode = new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT);</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">    int sc = canvas.save(Canvas.ALL_SAVE_FLAG);</div><div class="line">    synchronized (mSvgLock) &#123;</div><div class="line">        int count = mPaths.size();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            int pc = canvas.save(Canvas.ALL_SAVE_FLAG);</div><div class="line">            PathLayer.SvgPath svgPath = mPaths.get(i);</div><div class="line">            if (isFill) &#123;</div><div class="line">                //需要备用一个完整的path路径，来修复pathPaint的Fill造成绘制过度</div><div class="line">                Path path = pathLayer.mDrawer.get(i);</div><div class="line">                canvas.clipPath(path);</div><div class="line">                if (isDrawing &amp;&amp; svgPath.isMeasure) &#123;</div><div class="line">                    canvas.drawPath(path, drawerPaint);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            canvas.drawPath(svgPath.path, pathPaint);</div><div class="line">            canvas.restoreToCount(pc);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    canvas.restoreToCount(sc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2510337-d1414a0cd9abb9cd.gif?imageMogr2/auto-orient/strip" alt="nancy2.gif"><br>关于为什么要使用PorterDuff.Mode.SRC_OUT，其实我是试出来的0.0，本以为这样就完美了，但是我发现当仔细看发现颜色他么怎么变成黑色了（我用的是灰色）！！！然后我尝试了使用一张Bitmap的Canvas来代替view的Canvas再渲染像素点的颜色的时候，发现效果又乱了！！！！真是奇怪，为了研究原因我将 canvas.clipPath(path);去掉，发现了新大陆,看图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2510337-0e6025018e95b1d1.gif?imageMogr2/auto-orient/strip" alt="noclip.gif"><br>原来PorterDuff.Mode.SRC_OUT将非覆盖面生成了矩形块，那么新思路就有了：<br>3.直接截取path的矩形块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (isFill) &#123;</div><div class="line">              //需要备用一个完整的path路径，来修复pathPaint的Fill造成绘制过度</div><div class="line">              Path path = pathLayer.mDrawer.get(i);</div><div class="line">              canvas.clipPath(path);</div><div class="line">              svgPath.path.computeBounds(drawRect, true);</div><div class="line">              canvas.drawRect(drawRect, drawerPaint);</div><div class="line">          &#125;</div></pre></td></tr></table></figure></p>
<p>最终效果图就和文章最开始的显示效果一致了,哈哈 几经波折终于出现好效果啦!。</p>
<p>####如何制作svg<br>关于如何制作成这样的svg ，你可以考虑看我的文章：<a href="http://www.jianshu.com/p/d30bc9e83e00" target="_blank" rel="external">《如何将图片生成svg》</a>，使用的是Adobe Illustrator而不是GMIP2</p>
<p>##<strong>最后，如果你喜欢或者有何意见，不妨Star或者给我提Issuses哦！<a href="https://github.com/MartinBZDQSM/PathDraw" target="_blank" rel="external">项目地址</a></strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2510337-441047ef432479b0.gif?imageMogr2/auto-orient/strip" alt="帅.gif"></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Android/">Android</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/canvas/">canvas</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/matrix/">matrix</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/svg/">svg</a></li></ul>

      
        
	<div id="comment">
	
	<!-- 多说评论框 start -->
	 <div class="ds-thread" data-thread-key="/2017/01/16/Svg渐绘动画/" data-title="Svg渐绘动画" data-url="https://martinbzdqsm.github.io/2017/01/16/Svg渐绘动画/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"martinbzdqsm"};
	  (function() {
	    var ds = document.createElement('script');
	    ds.type = 'text/javascript';ds.async = true;
	    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	    ds.charset = 'UTF-8';
	    (document.getElementsByTagName('head')[0] 
	     || document.getElementsByTagName('body')[0]).appendChild(ds);
	  })();
	  </script>
	<!-- 多说公共JS代码 end -->
	
	</div>
	<link rel="stylesheet" href="/css/comment.css">


      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/01/16/利用Matrix让蝴蝶动起来/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">利用Matrix让蝴蝶动起来</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#动画效果"><span class="nav-number">1.</span> <span class="nav-text">动画效果</span></a></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2017 Martin Blog All Rights Reserved.
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var contentdiv = document.getElementById("content");

    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>





  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
  

  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1261148219&web_id=1261148219" language="JavaScript"></script>
  </div>


</body>
</html>
